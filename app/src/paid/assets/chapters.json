[
  {
    "id": 0,
    "color": "#16A085",
    "name": "Java Building Blocks",
    "questions": [
      {
        "id": 0,
        "chapterId": 0,
        "type": 2,
        "statement": "Which of the following are valid Java identifiers? (Choose all that apply)",
        "explanation": "Option A is valid because you can use the dollar sign in identifiers. Option B is valid because you can use an underscore in identifiers. Option C is not a valid identifier because true is a Java reserved word. Option D is not valid because the dot (.) is not allowed in identifiers. Option E is valid because Java is case sensitive, so Public is not a reserved word and therefore a valid identifier. Option F is not valid because the first character is not a letter, $, or _.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "A$B",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "_helloWorld",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "true",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "java.lang",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "Public",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "1980_s",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 1,
        "chapterId": 0,
        "type": 1,
        "statement": "What is the output of the following program?\n1: public class WaterBottle {\n2: private String brand;\n3: private boolean empty;\n4: public static void main(String[] args) {\n5:  WaterBottle wb = new WaterBottle();\n6:   System.out.print(\"Empty = \" + wb.empty);\n7:   System.out.print(\", Brand = \" + wb.brand);\n8: } }",
        "explanation": "Boolean fields initialize to false and references initialize to null, so empty is false and brand is null. Brand = null is output.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "Line 6 generates a compiler error.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "Line 7 generates a compiler error.",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "There is no output.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "Empty = false, Brand = null",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "Empty = false, Brand =",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "Empty = null, Brand = null",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 2,
        "chapterId": 0,
        "type": 2,
        "statement": "Which of the following are true? (Choose all that apply)\n4: short numPets = 5;\n5: int numGrains = 5.6;\n6: String name = \"Scruffy\";\n6: numPets.length();\n8: numGrains.length();\n9: name.length();",
        "explanation": "Option A (line 4) compiles because short is an integral type. Option B (line 5) generates a compiler error because int is an integral type, but 5.6 is a floating-point type. Option C (line 6) compiles because it is assigned a String. Options D and E (lines 7 and 8) do not compile because short and int are primitives. Primitives do not allow methods to be called on them. Option F (line 9) compiles because length() is defined on String.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "Line 4 generates a compiler error.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "Line 5 generates a compiler error.",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "Line 6 generates a compiler error.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "Line 7 generates a compiler error.",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "Line 8 generates a compiler error.",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "Line 9 generates a compiler error.",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "The code compiles as is.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 3,
        "chapterId": 0,
        "type": 2,
        "statement": "Given the following class, which of the following is true? (Choose all that apply)\n1: public class Snake {\n2:  public void shed(boolean time) {\n3:    if (time) {\n4:  }\n5:    System.out.println(result);\n6:  }\n7:}",
        "explanation": "Adding the variable at line 2 makes result an instance variable. Since instance variables are in scope for the entire life of the object, option A is correct. Option B is correct because adding the variable at line 4 makes result a local variable with a scope of the whole method. Adding the variable at line 6 makes result a local variable with a scope of lines 6–7. Since it is out of scope on line 8, the println does not compile and option C is incorrect. Adding the variable at line 9 makes result a local variable with a scope of lines 9 and 10. Since line 8 is before the declaration, it does not compile and option D is incorrect. Finally, option E is incorrect because the code can be made to compile.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "If String result = \"done\"; is inserted on line 2, the code will compile.",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "If String result = \"done\"; is inserted on line 4, the code will compile.",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "If String result = \"done\"; is inserted on line 6, the code will compile.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "If String result = \"done\"; is inserted on line 9, the code will compile.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "None of the above changes will make the code compile.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 4,
        "chapterId": 0,
        "type": 2,
        "statement": "Given the following classes, which of the following can independently replace INSERT IMPORTS HERE to make the code compile? (Choose all that apply)\n\npackage aquarium; \npublic class Tank { }\n\npackage aquarium.jellies; \npublic class Jelly { }\n\npackage visitor;\nINSERT IMPORTS HERE\npublic class AquariumVisitor {\npublic void admire(Jelly jelly) { } }",
        "explanation": "Option C is correct because it imports Jelly by classname. Option D is cor- rect because it imports all the classes in the jellies package, which includes Jelly. Option A is incorrect because it only imports classes in the aquarium package—Tank in this case—and not those in lower-level packages. Option B is incorrect because you cannot use wildcards anyplace other than the end of an import statement. Option E is incorrect because you cannot import parts of a class with a regular import statement. Option F is incorrect because options C and D do make the code compile.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "import aquarium.*;",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "import aquarium.*.Jelly;",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "import aquarium.jellies.Jelly;",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "import aquarium.jellies.*;",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "import aquarium.jellies.Jelly.*;",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "None of these can make the code compile.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 5,
        "chapterId": 0,
        "type": 1,
        "statement": "Given the following classes, what is the maximum number of imports that can be removed and have the code still compile?\npackage aquarium; public class Water { }\n\npackage aquarium;\nimport java.lang.*;\nimport java.lang.System; \nimport aquarium.Water; \nimport aquarium.*; \npublic class Tank {\npublic void print(Water water) { \n System.out.println(water); } }",
        "explanation": "The first two imports can be removed because java.lang is automatically imported. The second two imports can be removed because Tank and Water are in the same pack- age, making the correct answer E. If Tank and Water were in different packages, one of these two imports could be removed. In that case, the answer would be option D.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "0",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "1",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "2",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "3",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "4",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "5",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "Does not compile.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 6,
        "chapterId": 0,
        "type": 2,
        "statement": "Given the following classes, which of the following snippets can be inserted in place of INSERT IMPORTS HERE and have the code compile? (Choose all that apply)\npackage aquarium;\npublic class Water {\n  boolean salty = false; \n}\npackage aquarium.jellies; public class Water {\n  boolean salty = true; \n}\npackage employee; \nINSERT IMPORTS HERE\npublic class WaterFiller { \n  Water water;\n}",
        "explanation": "Option A is correct because it imports all the classes in the aquarium package including aquarium.Water. Options B and C are correct because they import Water by classname. Since importing by classname takes precedence over wildcards, these com- pile. Option D is incorrect because Java doesn’t know which of the two wildcard Water classes to use. Option E is incorrect because you cannot specify the same classname in two imports.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "import aquarium.*;",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "import aquarium.Water;\nimport aquarium.jellies.*;",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "import aquarium.*;\nimport aquarium.jellies.Water;",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "import aquarium.*;\nimport aquarium.jellies.*;",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "import aquarium.Water;\nimport aquarium.jellies.Water;",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "None of these imports can make the code compile.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 7,
        "chapterId": 0,
        "type": 2,
        "statement": "Given the following class, which of the following calls print out Blue Jay? (Choose all that apply)\npublic class BirdDisplay {\npublic static void main(String[] name) { \n  System.out.println(name[1]);\n}}",
        "explanation": "Option B is correct because arrays start counting from zero and strings with spaces must be in quotes. Option A is incorrect because it outputs Blue. C is incorrect because it outputs Jay. Option D is incorrect because it outputs Sparrow. Options E and F are incorrect because they output Error: Could not find or load main class Bird- Display.class.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "java BirdDisplay Sparrow Blue Jay",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "java BirdDisplay Sparrow \"Blue Jay\"",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "java BirdDisplay Blue Jay Sparrow",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "java BirdDisplay \"Blue Jay\" Sparrow",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "java BirdDisplay.class Sparrow \"Blue Jay\"",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "java BirdDisplay.class \"Blue Jay\" Sparrow",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "Does not compile.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 8,
        "chapterId": 0,
        "type": 2,
        "statement": "Which of the following legally fill in the blank so you can run the main() method from the command line? (Choose all that apply)\npublic static void main(   )",
        "explanation": "Option A is correct because it is the traditional main() method signature and variables may begin with underscores. Options C and D are correct because the array operator may appear after the variable name. Option E is correct because varargs are allowed in place of an array. Option B is incorrect because variables are not allowed to begin with a digit. Option F is incorrect because the argument must be an array or varargs. Option F is a perfectly good method. However, it is not one that can be run from the command line because it has the wrong parameter type.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "String[] _names",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "String[] 123",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "String abc[]",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "String _Names[]",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "String... $n",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "String names",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "None of the above.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 9,
        "chapterId": 0,
        "type": 2,
        "statement": "Which of the following are legal entry point methods that can be run from the command line? (Choose all that apply)",
        "explanation": "Option E is the canonical main() method signature. You need to memorize it. Option A is incorrect because the main() method must be public. Options B and F are incorrect because the main() method must have a void return type. Option C is incorrect because the main() method must be static. Option D is incorrect because the main() method must be named main.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "private static void main(String[] args)",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "public static final main(String[] args)",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "public void main(String[] args)",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "public static void test(String[] args)",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "public static void main(String[] args)",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "public static main(String[] args)",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "None of the above.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 10,
        "chapterId": 0,
        "type": 2,
        "statement": "Which of the following are true? (Choose all that apply)",
        "explanation": "Option C is correct because all non-primitive values default to null. Option D is correct because float and double primitives default to 0.0. Options B and E are incor- rect because int primitives default to 0.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "An instance variable of type double defaults to null.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "An instance variable of type int defaults to null.",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "An instance variable of type String defaults to null.",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "An instance variable of type double defaults to 0.0.",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "An instance variable of type int defaults to 0.0.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "An instance variable of type String defaults to 0.0.",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "None of the above.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 11,
        "chapterId": 0,
        "type": 2,
        "statement": "Which of the following are true? (Choose all that apply)",
        "explanation": "Option G is correct because local variables do not get assigned default values. The code fails to compile if a local variable is not explicitly initialized. If this question were about instance variables, options D and F would be correct. A boolean primitive defaults to false and a float primitive defaults to 0.0.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "A local variable of type boolean defaults to null.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "A local variable of type float defaults to 0.",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "A local variable of type Object defaults to null.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "A local variable of type boolean defaults to false.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "A local variable of type boolean defaults to true.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "A local variable of type float defaults to 0.0.",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "None of the above.",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 12,
        "chapterId": 0,
        "type": 2,
        "statement": "Which of the following are true? (Choose all that apply)",
        "explanation": "Options A and D are correct because boolean primitives default to false and int primitives default to 0.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "An instance variable of type boolean defaults to false.",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "An instance variable of type boolean defaults to true.",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "An instance variable of type boolean defaults to null.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "An instance variable of type int defaults to 0.",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "An instance variable of type int defaults to 0.0.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "An instance variable of type int defaults to null.",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "None of the above..",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 13,
        "chapterId": 0,
        "type": 2,
        "statement": "Given the following class in the file /my/directory/named/A/Bird.java: \nINSERT CODE HERE \npublic class Bird { }\nWhich of the following replaces INSERT CODE HERE if we compile from /my/directory? (Choose all that apply)",
        "explanation": "The package name represents any folders underneath the current path, which is named.A in this case. Option B is incorrect because package names are case sensitive, just like variable names and other identifiers.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "package my.directory.named.a;",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "package my.directory.named.A;",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "package named.a;",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "package named.A;",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "package a;",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "package A;",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "Does not compile.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 14,
        "chapterId": 0,
        "type": 2,
        "statement": "Which of the following lines of code compile? (Choose all that apply)",
        "explanation": "Underscores are allowed as long as they are directly between two other digits. This means options A and E are correct. Options B and C are incorrect because the underscore is adjacent to the decimal point. Option D is incorrect because the under- score is the last character.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "int i1 = 1_234;",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "double d1 = 1_234_.0;",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "double d2 = 1_234._0;",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "double d3 = 1_234.0_;",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "double d4 = 1_234.0;",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "None of the above.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 15,
        "chapterId": 0,
        "type": 2,
        "statement": "Given the following class, which of the following lines of code can replace INSERT CODE HERE to make the code compile? (Choose all that apply)\npublic class Price {\n  public void admission() { \n    INSERT CODE HERE\n    System.out.println(amount);\n  }}",
        "explanation": "0b is the prefix for a binary value and is correct. 0x is the prefix for a hexa- decimal value. This value can be assigned to many primitive types, including int and double, making options C and D correct. Option A is incorrect because 9L is a long value. long amount = 9L would be allowed. Option E is incorrect because the under- score is immediately before the decimal. Option F is incorrect because the underscore is the very last character.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "int amount = 9L;",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "int amount = 0b101;",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "int amount = 0xE;",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "double amount = 0xE;",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "double amount = 1_2_.0_0;",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "int amount = 1_2_;",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "None of the above.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 16,
        "chapterId": 0,
        "type": 2,
        "statement": "Which of the following are true? (Choose all that apply)\npublic class Bunny {\n  public static void main(String[] args) { \n    Bunny bun = new Bunny();\n}}",
        "explanation": "Bunny is a class, which can be seen from the declaration: public class Bunny. bun is a reference to an object. main() is a method.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "Bunny is a class.",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "bun is a class.",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "main is a class.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "Bunny is a reference to an object.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "bun is a reference to an object.",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "main is a reference to an object.",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "None of the above.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 17,
        "chapterId": 0,
        "type": 2,
        "statement": "Which represent the order in which the following statements can be assembled into a pro- gram that will compile successfully? (Choose all that apply)\nA: class Rabbit {}\nB: import java.util.*; \nC: package animals;",
        "explanation": "package and import are both optional. If both are present, the order must be package, then import, then class. Option A is incorrect because class is before package and import. Option B is incorrect because import is before package. Option F is incorrect because class is before package. Option G is incorrect because class is before import.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "A,B,C",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "B,C,A",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "C,B,A",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "B,A",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "C,A",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "A,C",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "A,B",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 18,
        "chapterId": 0,
        "type": 2,
        "statement": "Suppose we have a class named Rabbit. Which of the following statements are true? (Choose all that apply)\n1: public class Rabbit {\n2: public static void main(String[] args) {\n3:  Rabbit one = new Rabbit();\n4:  Rabbit two = new Rabbit();\n5:  Rabbit three = one;\n6:  one = null;\n7:  Rabbit four = one;\n8:  three = null;\n9:  two = null;\n10:  two = new Rabbit();\n11: System.gc();\n} }",
        "explanation": "The Rabbit object from line 3 has two references to it: one and three. The ref- erences are nulled out on lines 6 and 8, respectively. Option B is correct because this makes the object eligible for garbage collection after line 8. Line 7 sets the reference four to the now null one, which means it has no effect on garbage collection. The Rab- bit object from line 4 only has a single reference to it: two. Option D is correct because this single reference becomes null on line 9. The Rabbit object declared on line 10 becomes eligible for garbage collection at the end of the method on line 12. Calling System.gc() has no effect on eligibility for garbage collection.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "The Rabbit object from line 3 is first eligible for garbage collection immediately following line 6.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "The Rabbit object from line 3 is first eligible for garbage collection immediately following line 8.",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "The Rabbit object from line 3 is first eligible for garbage collection immediately following line 12.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "The Rabbit object from line 4 is first eligible for garbage collection immediately following line 9.",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "The Rabbit object from line 4 is first eligible for garbage collection immediately following line 11.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "The Rabbit object from line 4 is first eligible for garbage collection immediately following line 12.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 19,
        "chapterId": 0,
        "type": 2,
        "statement": "What is true about the following code? (Choose all that apply) public class Bear {\n protected void finalize() { \n  System.out.println(\"Roar!\");\n}\n\npublic static void main(String[] args) { \n Bear bear = new Bear();\n bear = null;\n System.gc();\n}}",
        "explanation": "Calling System.gc() suggests that Java might wish to run the garbage collector. Java is free to ignore the request, making option E correct. finalize() runs if an object attempts to be garbage collected, making option B correct.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "finalize() is guaranteed to be called.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "finalize() might or might not be called",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "finalize() is guaranteed not to be called.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "Garbage collection is guaranteed to run.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "Garbage collection might or might not run.",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "Garbage collection is guaranteed not to run.",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "The code does not compile.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 20,
        "chapterId": 0,
        "type": 1,
        "statement": "What does the following code output?\n1: public class Salmon {\n2:  int count;\n3:  public void Salmon() {\n4:  count = 4;\n5: }\n6: public static void main(String[] args) {\n7: Salmon s = new Salmon();\n8:  System.out.println(s.count);\n9: } }",
        "explanation": "Whilethecodeonline3doescompile,itisnotaconstructorbecauseithasareturn type. It is a method that happens to have the same name as the class. When the code runs, the default constructor is called and count has the default value (0) for an int.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "0",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "4",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "Compilation fails on line 3.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "Compilation fails on line 4.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "Compilation fails on line 7.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "Compilation fails on line 8.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 21,
        "chapterId": 0,
        "type": 2,
        "statement": "Which of the following are true statements? (Choose all that apply)",
        "explanation": "C++ has operator overloading and pointers. Java made a point of not having either. Java does have references to objects, but these are pointing to an object that can move around in memory. Option B is correct because Java is platform independent. Option E is correct because Java is object oriented. While it does support some parts of functional programming, these occur within a class.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "Java allows operator overloading.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "Java code compiled on Windows can run on Linux.",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "Java has pointers to specific locations in memory.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "Java is a procedural language.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "Java is an object-oriented language.",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "Java is a functional programming language.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 22,
        "chapterId": 0,
        "type": 2,
        "statement": "Which of the following are true? (Choose all that apply)",
        "explanation": "Java puts source code in .java files and bytecode in .class files. It does not use a .bytecode file. When running a Java program, you pass just the name of the class without the .class extension.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "javac compiles a .class file into a .java file.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "javac compiles a .java file into a .bytecode file.",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "javac compiles a .java file into a .class file.",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "Java takes the name of the class as a parameter.",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "Java takes the name of the .bytecode file as a parameter.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "Java takes the name of the .class file as a parameter.",
            "isCorrect": false
          }
        ]
      }
    ]
  },
  {
    "id": 1,
    "color": "#27AE60",
    "name": "Operators and Statements",
    "questions": [
      {
        "id": 23,
        "chapterId": 1,
        "type": 2,
        "statement": "Which of the following Java operators can be used with boolean variables? (Choose all that apply)",
        "explanation": "Option A is the equality operator and can be used on numeric primitives, bool- ean values, and object references. Options B and C are both arithmetic operators and cannot be applied to a boolean value. Option D is the logical complement operator and is used exclusively with boolean values. Option E is the modulus operator, which can only be used with numeric primitives. Finally, option F is a relational operator that compares the values of two numbers.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "==",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "+",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "--",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "!",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "%",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "<=",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 24,
        "chapterId": 1,
        "type": 2,
        "statement": "What data type (or types) will allow the following code snippet to compile? (Choose all that apply)\nbyte x = 5;\nbyte y = 10;\n _____ z = x + y;",
        "explanation": "The value x + y is automatically promoted to int, so int and data types that can be promoted automatically from int will work. Options A, B, D are such data types. Option C will not work because boolean is not a numeric data type. Options E and F will not work without an explicit cast to a smaller data type.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "int",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "long",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "boolean",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "double",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "short",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "byte",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 25,
        "chapterId": 1,
        "type": 1,
        "statement": "What is the output of the following application?\n1: public class CompareValues {\n2: public static void main(String[] args) {\n3: int x = 0;\n4: while(x++ < 10) {}\n5: String message = x > 10 ? \"Greater than\" : false;\n6: System.out.println(message+\",\"+x);\n7: }\n8: }",
        "explanation": "In this example, the ternary operator has two expressions, one of them a String and the other a boolean value. The ternary operator is permitted to have expressions that don’t have matching types, but the key here is the assignment to the String reference. The compiler knows how to assign the first expression value as a String, but the sec- ond boolean expression cannot be set as a String; therefore, this line will not compile.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "Greater than,10",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "false,10",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "Greater than,11",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "false,11",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "The code will not compile because of line 4.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "The code will not compile because of line 5.",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 26,
        "chapterId": 1,
        "type": 2,
        "statement": "What change would allow the following code snippet to compile? (Choose all that apply)\n3: long x = 10;\n4: int y = 2 * x;",
        "explanation": "The code will not compile as is, so option A is not correct. The value 2 * x is automatically promoted to long and cannot be automatically stored in y, which is in an int value. Options B, C, and D solve this problem by reducing the long value to int. Option E does not solve the problem and actually makes it worse by attempting to place the value in a smaller data type. Option F solves the problem by increasing the data type of the assignment so that long is allowed.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "No change; it compiles as is.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "Cast x on line 4 to int.",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "Change the data type of x on line 3 to short.",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "Cast2 * xonline4toint.",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "Change the data type of y on line 4 to short.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "Change the data type of y on line 4 to long.",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 27,
        "chapterId": 1,
        "type": 1,
        "statement": "What is the output of the following code snippet?\n3: java.util.List<Integer> list = new java.util.ArrayList<Integer>();\n4: list.add(10);\n5: list.add(14);\n6: for(int x : list) {\n7:  System.out.print(x + \", \");\n8:  break;\n9:}",
        "explanation": "meh",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "10, 14,",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "10, 14",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "10,",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "The code will not compile because of line 7.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "The code will not compile because of line 8.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "The code contains an infinite loop and does not terminate.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 28,
        "chapterId": 1,
        "type": 1,
        "statement": "What is the output of the following code snippet?\n3: int x = 4;\n4: long y = x * 4 - x++;\n5: if(y<10) System.out.println(\"Too Low\");\n6: else System.out.println(\"Just right\");\n7: else System.out.println(\"Too High\");",
        "explanation": "The code does not compile because two else statements cannot be chained together without additional if-then statements, so the correct answer is option F. Option E is incorrect as Line 6 by itself does not cause a problem, only when it is paired with Line 7. One way to fix this code so it compiles would be to add an if-then statement on line 6. The other solution would be to remove line 7.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "Too Low",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "Just Right",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "Too High",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "Compiles but throws a NullPointerException.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "The code will not compile because of line 6.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "The code will not compile because of line 7.",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 29,
        "chapterId": 1,
        "type": 1,
        "statement": "What is the output of the following code?\n1: public class TernaryTester {\n2:  public static void main(String[] args) {\n3:   int x = 5;\n4:   System.out.println(x > 2 ? x < 4 ? 10 : 8 : 7);\n5: } }",
        "explanation": "As you learned in the section “Ternary Operator,” although parentheses are not required, they do greatly increase code readability, such as the following equivalent statement:\nSystem.out.println((x > 2) ? ((x < 4) ? 10 : 8) : 7)\nWe apply the outside ternary operator  rst, as it is possible the inner ternary expression may never be evaluated. Since (x>2) is true, this reduces the problem to: System.out.println((x < 4) ? 10 : 8)\nSince x is greater than 2, the answer is 8, or option D in this case.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "5",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "4",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "10",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "8",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "7",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "The code will not compile because of line 4.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 30,
        "chapterId": 1,
        "type": 1,
        "statement": "What is the output of the following code snippet?\n3: boolean x = true, z = true;\n4: int y = 20;\n5: x = (y != 10) ^ (z=false);\n6: System.out.println(x+\", \"+y+\", \"+z);",
        "explanation": "This example is tricky because of the second assignment operator embedded in line 5. The expression (z=false) assigns the value false to z and returns false for the entire expression. Since y does not equal 10, the left-hand side returns true; therefore, the exclusive or (^) of the entire expression assigned to x is true. The output reflects these assignments, with no change to y, so option B is the only correct answer. The code compiles and runs without issue, so option F is not correct.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "true, 10, true",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "true, 20, false",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "false, 20, true",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "false, 20, false",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "false, 20, true",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "The code will not compile because of line 5.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 31,
        "chapterId": 1,
        "type": 1,
        "statement": "How many times will the following code print \"Hello World\"?\n3: for(int i=0; i<10 ; ) {\n4: i = i++;\n5: System.out.println(\"Hello World\");\n6: }",
        "explanation": "In this example, the update statement of the for loop is missing, which is fine as the statement is optional, so option D is incorrect. The expression inside the loop incre- ments i but then assigns i the old value. Therefore, i ends the loop with the same value that it starts with: 0. The loop will repeat infinitely, outputting the same statement over and over again because i remains 0 after every iteration of the loop.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "9",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "10",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "11",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "The code will not compile because of line 3.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "The code will not compile because of line 5.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "The code contains an infinite loop and does not terminate.",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 32,
        "chapterId": 1,
        "type": 1,
        "statement": "What is the output of the following code?\n3: byte a = 40, b = 50;\n4: byte sum = (byte) a + b;\n5: System.out.println(sum);",
        "explanation": "Line 4 generates a possible loss of precision compiler error. The cast operator has the highest precedence, so it is evaluated first, casting a to a byte. Then, the addition is evaluated, causing both a and b to be promoted to int values. The value 90 is an int and cannot be assigned to the byte sum without an explicit cast, so the code does not compile. The code could be corrected with parentheses around (a + b), in which case option C would be the correct answer.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "40",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "50",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "90",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "The code will not compile because of line 4.",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "An undefined value.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 33,
        "chapterId": 1,
        "type": 1,
        "statement": "What is the output of the following code?\n1: public class ArithmeticSample {\n2:  public static void main(String[] args) {\n3:   int x = 5 * 4 % 3;\n4:   System.out.println(x);\n5:} }",
        "explanation": "The * and % have the same operator precedence, so the expression is evaluated from left-to-right. The result of 5 * 4 is 20, and 20 % 3 is 2 (20 divided by 3 is 18, the remainder is 2). The output is 2 and option A is the correct answer.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "2",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "3",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "5",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "6",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "The code will not compile because of line 3.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 34,
        "chapterId": 1,
        "type": 1,
        "statement": "What is the output of the following code snippet?\n3: int x = 0;\n4: String s = null;\n5: if(x == s) System.out.println(\"Success\");\n6: else System.out.println(\"Failure\");",
        "explanation": "The variable x is an int and s is a reference to a String object. The two data types are incomparable because neither variable can be converted to the other variable’s type. The compiler error occurs on line 5 when the comparison is attempted, so the answer is option D.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "Success",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "Failure",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "The code will not compile because of line 4.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "The code will not compile because of line 5.",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 144,
        "chapterId": 1,
        "type": 1,
        "statement": "What is the output of the following code snippet?\n3: int x1 = 50, x2 = 75;\n4: boolean b = x1 >= x2;\n5: if(b == true) System.out.println(\"Success\");\n6: else System.out.println(\"Failure\");",
        "explanation": "The code compiles successfully, so options C and D are incorrect. The value of b after line 4 is false. However, the if-then statement on line 5 contains an assignment, not a comparison. The variable b is assigned true on line 3, and the assignment opera- tor returns true, so line 5 executes and displays Success, so the answer is option A.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "Success",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "Failure",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "The code will not compile because of line 4.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "The code will not compile because of line 5.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 35,
        "chapterId": 1,
        "type": 1,
        "statement": "What is the output of the following code snippet? 3: int c = 7;\n4: int result = 4;\n5: result += ++c;\n6: System.out.println(result);",
        "explanation": "The code compiles successfully, so option F is incorrect. On line 5, the pre-incre- ment operator is used, so c is incremented to 4 and the new value is returned to the expression. The value of result is computed by adding 4 to the original value of 8, resulting in a new value of 12, which is output on line 6. Therefore, option C is the correct answer.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "8",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "11",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "12",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "15",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "16",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "The code will not compile because of line 5.",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 36,
        "chapterId": 1,
        "type": 1,
        "statement": "What is the output of the following code snippet?\n3: int x = 1, y = 15;\n4: while x < 10\n5:  y––;\n6:  x++;\n7: System.out.println(x+\", \"+y);",
        "explanation": "This is actually a much simpler problem than it appears to be. The while statement on line 4 is missing parentheses, so the code will not compile, and option E is the cor- rect answer. If the parentheses were added, though, option F would be the correct answer since the loop does not use curly braces to include x++ and the boolean expres- sion never changes. Finally, if curly braces were added around both expressions, the output would be 10, 6 and option B would be correct.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "10, 5",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "10, 6",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "11, 5",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "The code will not compile because of line 3.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "The code will not compile because of line 4.",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "The code contains an infinite loop and does not terminate.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 37,
        "chapterId": 1,
        "type": 1,
        "statement": "What is the output of the following code snippet?\n3: do {\n4: int y = 1;\n5: System.out.print(y++ + \" \");\n6: } while(y <= 10);",
        "explanation": "The variable y is declared within the body of the do-while statement, so it is out of scope on line 6. Line 6 generates a compiler error, so option D is the correct answer.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "1 2 3 4 5 6 7 8 9",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "1 2 3 4 5 6 7 8 9 10",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "1 2 3 4 5 6 7 8 9 10 11",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "The code will not compile because of line 6.",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "The code contains an infinite loop and does not terminate.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 38,
        "chapterId": 1,
        "type": 1,
        "statement": "What is the output of the following code snippet?\n3: boolean keepGoing = true;\n4: int result = 15, i = 10;\n5: do {\n6: i--;\n7:  if(i==8) keepGoing = false;\n8:  result -= 2;\n9: } while(keepGoing);\n10: System.out.println(result);",
        "explanation": "The code compiles without issue, so option F is incorrect. After the first execution of the loop, i is decremented to 9 and result to 13. Since i is not 8, keepGoing is false, and the loop continues. On the next iteration, i is decremented to 8 and result to 11. On the second execution, i does equal 8, so keepGoing is set to false. At the conclusion of the loop, the loop terminates since keepGoing is no longer true. The value of result is 11, and the correct answer is option D.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "7",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "9",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "10",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "11",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "15",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "The code will not compile because of line 8.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 39,
        "chapterId": 1,
        "type": 1,
        "statement": "What is the output of the following code snippet?\n3: int count = 0;\n4: ROW_LOOP: for(int row = 1; row <=3; row++)\n5:  for(int col = 1; col <=2 ; col++) {\n6:   if(row * col % 2 == 0) continue ROW_LOOP;\n7:   count++;\n8:  }\n9: System.out.println(count);",
        "explanation": "The expression on line 5 is true when row * col is an even number. On the first iteration, row = 1 and col = 1, so the expression on line 6 is false, the continue is skipped, and count is incremented to 1. On the second iteration, row = 1 and col = 2, so the expression on line 6 is true and the continue ends the outer loop with count still at 1. On the third iteration, row = 2 and col = 1, so the expression on line 6 is true and the continue ends the outer loop with count still at 1. On the fourth iteration, row = 3 and col = 1, so the expression on line 6 is false, the continue is skipped, and count is incremented to 2. Finally, on the fifth and final iteration, row = 3 and col = 2, so the expression on line 6 is true and the continue ends the outer loop with count still at 2. The result of 2 is displayed, so the answer is option B.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "1",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "2",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "3",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "4",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "6",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "The code will not compile because of line 6.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 40,
        "chapterId": 1,
        "type": 1,
        "statement": "What is the result of the following code snippet?\n3: int m = 9, n = 1, x = 0;\n4: while(m > n) {\n5:  m--;\n6:  n += 2;\n7:  x += m + n;\n8: }\n9 System.out.println(x);",
        "explanation": "Prior to the first iteration, m = 9, n = 1, and x = 0. After the iteration of the first loop, m is updated to 8, n to 3, and x to the sum of the new values for m + n, 0 + 11 = 11. After the iteration of the second loop, m is updated to 7, n to 5, and x to the sum of the new values for m + n, 11 + 12 = 23. After the iteration of the third loop, m is updated to 6, n to 7, and x to the sum of the new values for m + n, 23 + 13 = 36. On the fourth iteration of the loop, m > n evaluates to false, as 6 < 7 is not true. The loop ends and the most recent value of x, 36, is output, so the correct answer is option D.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "11",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "13",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "23",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "36",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "50",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "The code will not compile because of line 7.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 41,
        "chapterId": 1,
        "type": 1,
        "statement": "What is the result of the following code snippet? 3: final char a = 'A', d = 'D';\n4: char grade = 'B';\n5: switch(grade) {\n6:  case a:\n7:  case 'B': System.out.print(\"great\");\n8:  case 'C': System.out.print(\"good\"); break;\n9:  case d:\n10:  case 'F': System.out.print(\"not good\");\n11: }",
        "explanation": "The code compiles and runs without issue,so options C,D,and E are not correct.The value of grade is 'B' and there is a matching case statement that will cause \"great\" to be printed. There is no break statement after the case, though, so the next case state- ment will be reached, and \"good\" will be printed. There is a break after this case state- ment, though, so the switch statement will end. The correct answer is thus option B.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "great",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "greatgood",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "The code will not compile because of line 3.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "The code will not compile because of line 6.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "The code will not compile because of lines 6 and 9.",
            "isCorrect": false
          }
        ]
      }
    ]
  },
  {
    "id": 2,
    "color": "#2980B9",
    "name": "Core Java APIs",
    "questions": [
      {
        "id": 42,
        "chapterId": 2,
        "type": 1,
        "statement": "What is output by the following code? (Choose all that apply)\n1: public class Fish {\n2:  public static void main(String[] args) {\n3:   int numFish = 4;\n4:   String fishType = \"tuna\";\n5:   String anotherFish = numFish + 1;\n6:   System.out.println(anotherFish + \" \" + fishType);\n7:   System.out.println(numFish + \" \" + 1);\n8:} }",
        "explanation": "Line 5 does not compile. This question is checking to see if you are paying attention to the types. numFish is an int and 1 is an int. Therefore, we use numeric addition and get 5. The problem is that we can’t store an int in a String variable. Supposing line 5 said String anotherFish = numFish + 1 + \"\";. In that case, the answer would be options A and D. The variable defined on line 5 would be the string \"5\", and both out- put statements would use concatenation.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "4 1",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "41",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "5",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "5 tuna",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "5tuna",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "51tuna",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "The code does not compile",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 43,
        "chapterId": 2,
        "type": 2,
        "statement": "Which of the following are output by this code? (Choose all that apply) \n3: String s = \"Hello\";\n4: String t = new String(s);\n5: if (\"Hello\".equals(s)) System.out.println(\"one\");\n6: if (t == s) System.out.println(\"two\");\n7: if (t.equals(s)) System.out.println(\"three\"); \n8: if (\"Hello\" == s) System.out.println(\"four\"); \n9: if (\"Hello\" == t) System.out.println(\"five\");",
        "explanation": "The code compiles fine. Line 3 points to the String in the string pool. Line 4 calls the String constructor explicitly and is therefore a different object than s. Lines 5 and 7 check for object equality, which is true, and so print one and three. Line 6 uses object reference equality, which is not true since we have different objects. Line 7 also compares references but is true since both references point to the object from the string pool. Finally, line 8 compares one object from the string pool with one that was explic- itly constructed and returns false.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "one",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "two",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "three",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "four",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "five",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "The code does not compile.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 44,
        "chapterId": 2,
        "type": 2,
        "statement": "Which are true statements? (Choose all that apply)",
        "explanation": "Immutable means the state of an object cannot change once it is created. Immutable objects can be garbage collected just like mutable objects. String is immu- table. StringBuilder can be mutated with methods like append(). Although StringBuffer isn’t on the exam, you should know about it anyway in case older ques- tions haven’t been removed.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "An immutable object can be modified.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "An immutable object cannot be modified.",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "An immutable object can be garbage collected.",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "An immutable object cannot be garbage collected.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "String is immutable.",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "StringBuffer is immutable.",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "StringBuilder is immutable.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 45,
        "chapterId": 2,
        "type": 1,
        "statement": "What is the result of the following code?\n7: StringBuilder sb = new StringBuilder();\n8: sb.append(\"aaa\").insert(1, \"bb\").insert(4, \"ccc\");\n9: System.out.println(sb);",
        "explanation": "This example uses method chaining. After the call to append(), sb contains \"aaa\". That result is passed to the first insert() call, which inserts at index 1. At this point sb contains abbbaa. That result is passed to the final insert(), which inserts at index 4, resulting in abbaccca.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "abbaaccc",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "abbaccca",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "bbaaaccc",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "bbaaccca",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "An exception is thrown.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "The code does not compile.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 46,
        "chapterId": 2,
        "type": 1,
        "statement": "What is the result of the following code?\n2: String s1 = \"java\";\n3: StringBuilder s2 = new StringBuilder(\"java\"); \n4: if (s1 == s2)\n5: System.out.print(\"1\"); 6: if (s1.equals(s2))\n7: System.out.print(\"2\");",
        "explanation": "The question is trying to distract you into paying attention to logical equality versus object reference equality. It is hoping you will miss the fact that line 4 does not com- pile. Java does not allow you to compare String and StringBuilder using ==.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "1",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "2",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "12",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "No output is printed.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "An exception is thrown.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "The code does not compile.",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 47,
        "chapterId": 2,
        "type": 1,
        "statement": "What is the result of the following code? public \nclass Lion {\npublic void roar(String roar1, StringBuilder roar2) { \nroar1.concat(\"!!!\");\nroar2.append(\"!!!\");\n}\npublic static void main(String[] args) {\nString roar1 = \"roar\";\nStringBuilder roar2 = new StringBuilder(\"roar\");\nnew Lion().roar(roar1, roar2);\nSystem.out.println(roar1 + \" \" + roar2); \n}}",
        "explanation": "A String is immutable. Calling concat() returns a new String but does not change the original. A StringBuilder is mutable. Calling append() adds characters to the existing character sequence along with returning a reference to the same object.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "roar roar",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "roar roar!!!",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "roar!!! roar",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "roar!!! roar!!!",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "An exception is thrown.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "The code does not compile.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 48,
        "chapterId": 2,
        "type": 2,
        "statement": "Which are the results of the following code? (Choose all that apply)\nString letters = \"abcdef\"; \nSystem.out.println(letters.length()); \nSystem.out.println(letters.charAt(3)); \nSystem.out.println(letters.charAt(6));",
        "explanation": "length() is simply a count of the number of characters in a String. In this case, there are six characters. charAt() returns the character at that index. Remember that indexes are zero based, which means that index 3 corresponds to d and index 6 corresponds to 1 past the end of the array. A StringIndexOutOfBoundsException is thrown for the last line.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "5",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "6",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "c",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "d",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "An exception is thrown.",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "The code does not compile.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 49,
        "chapterId": 2,
        "type": 2,
        "statement": "Which are the results of the following code? (Choose all that apply) \nString numbers = \"012345678\"; \nSystem.out.println(numbers.substring(1, 3)); \nSystem.out.println(numbers.substring(7, 7)); \nSystem.out.println(numbers.substring(7));",
        "explanation": "substring() has two forms. The first takes the index to start with and the index to stop immediately before. The second takes just the index to start with and goes to the end of the String. Remember that indexes are zero based. The first call starts at index 1 and ends with index 2 since it needs to stop before index 3. The sec- ond call starts at index 7 and ends in the same place, resulting in an empty String. This prints out a blank line. The final call starts at index 7 and goes to the end of the String.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "12",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "123",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "7",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "78",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "A blank line.",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "An exception is thrown.",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "The code does not compile.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 50,
        "chapterId": 2,
        "type": 1,
        "statement": "What is the result of the following code? \n3: String s = \"purr\";\n4: s.toUpperCase();\n5: s.trim();\n6: s.substring(1, 3);\n7: s += \" two\"; \n8: System.out.println(s.length());",
        "explanation": "This question is trying to see if you know that String objects are immutable. Line 4 returns \"PURR\" but the result is ignored and not stored in s. Line 5 returns \"purr\" since there is no whitespace present but the result is again ignored. Line 6 returns \"ur\" because it starts with index 1 and ends before index 3 using zero-based indexes. The result is ignored again. Finally, on line 6 something happens. We concatenate four new characters to s and now have a String of length 8.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "2",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "4",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "8",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "10",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "An exception is thrown.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "The code does not compile.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 51,
        "chapterId": 2,
        "type": 2,
        "statement": "What is the result of the following code? (Choose all that apply)\n13: String a = \"\"; \n14: a += 2;\n15: a += 'c';\n16: a += false;\n17: if ( a == \"2cfalse\") System.out.println(\"==\");\n18: if ( a.equals(\"2cfalse\")) System.out.println(\"equals\");",
        "explanation": "a += 2 expands to a = a + 2. A String concatenated with any other type gives a String. Lines 14, 15, and 16 all append to a, giving a result of \"2cfalse\". The if statement on line 18 returns false because the values of the two String objects are the same using object equality. The if statement on line 17 returns false because the two String objects are not the same in memory. One comes directly from the string pool and the other comes from building using String operations.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "Compile error on line 14.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "Compile error on line 15.",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "Compile error on line 16.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "Compile error on another line.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "==",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "equals",
            "isCorrect": true
          },
          {
            "id": 6,
            "answer": "An exception is thrown.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 52,
        "chapterId": 2,
        "type": 1,
        "statement": "What is the result of the following code?\n4: int total = 0;\n5: StringBuilder letters = new StringBuilder(\"abcdefg\");\n6: total += letters.substring(1, 2).length();\n7: total += letters.substring(6, 6).length();\n8: total += letters.substring(6, 5).length();\n9: System.out.println(total);",
        "explanation": "Line 6 adds 1 to total because substring() includes the starting index but not the ending index. Line 7 adds 0 to total. Line 8 is a problem: Java does not allow the indexes to be specified in reverse order and the code throws a StringIndexOutOf- BoundsException.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "1",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "2",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "3",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "7",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "An exception is thrown.",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "The code does not compile.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 53,
        "chapterId": 2,
        "type": 2,
        "statement": "What is the result of the following code? (Choose all that apply)\nStringBuilder numbers = new StringBuilder(\"0123456789\");\nnumbers.delete(2, 8);\nnumbers.append(\"-\").insert(2, \"+\");\nSystem.out.println(numbers);",
        "explanation": "First, we delete the characters at index 2 until the character one before index 8. At this point, 0189 is in numbers. The following line uses method chaining. It appends a dash to the end of the characters sequence, resulting in 0189–, and then inserts a plus sign at index 2, resulting in 01+89–.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "01+89–",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "012+9–",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "012+–9",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "0123456789",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "An exception is thrown.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "The code does not compile.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 54,
        "chapterId": 2,
        "type": 1,
        "statement": "What is the result of the following code?\nStringBuilder b = \"rumble\";\nb.append(4).deleteCharAt(3).delete(3, b.length() - 1);\nSystem.out.println(b);",
        "explanation": "This is a trick question. The first line does not compile because you cannot assign a String to a StringBuilder. If that line were StringBuilder b = new StringBuilder(\"rumble\"), the code would compile and print rum4. Watch out for this sort of trick on the exam. You could easily spend a minute working out the character positions for no reason at all.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "rum",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "rum4",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "rumb4",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "rumble4",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "An exception is thrown.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "The code does not compile.",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 55,
        "chapterId": 2,
        "type": 2,
        "statement": "Which of the following can replace line 4 to print \"avaJ\"? (Choose all that apply)\n3: StringBuilder puzzle = new StringBuilder(\"Java\");\n4: // INSERT CODE HERE\n5: System.out.println(puzzle);",
        "explanation": "The reverse() method is the easiest way of reversing the characters in a String- Builder; therefore, option A is correct. Option B is a nice distraction—it does in fact return \"avaJ\". However, substring() returns a String, which is not stored anywhere. Option C uses method chaining. First it creates the value \"JavavaJ$\". Then it removes the first three characters, resulting in \"avaJ$\". Finally, it removes the last character, resulting in \"avaJ\". Option D throws an exception because you cannot delete the char- acter after the last index. Remember that deleteCharAt() uses indexes that are zero based and length() counts starting with 1.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "puzzle.reverse();",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "puzzle.append(\"vaJ$\").substring(0, 4);",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "puzzle.append(\"vaJ$\").delete(0, 3).deleteCharAt(puzzle.length() - 1);",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "puzzle.append(\"vaJ$\").delete(0, 3).deleteCharAt(puzzle.length());",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "None of the above.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 56,
        "chapterId": 2,
        "type": 2,
        "statement": "Which of these array declarations is not legal? (Choose all that apply)",
        "explanation": "Option C uses the variable name as if it were a type, which is clearly illegal. Options E and F don’t specify any size. Although it is legal to leave out the size for later dimensions of a multidimensional array, the first one is required. Option A declares a legal 2D array. Option B declares a legal 3D array. Option D declares a legal 2D array. Remember that it is normal to see on the exam types you might not have learned. You aren’t expected to know anything about them.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "int[][] scores = new int[5][];",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "Object[][][] cubbies = new Object[3][0][5];",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "String beans[] = new beans[6];",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "java.util.Date[] dates[] = new java.util.Date[2][];",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "int[][] types = new int[];",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "int[][] java = new int[][];",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 57,
        "chapterId": 2,
        "type": 2,
        "statement": "Which of these compile when replacing line 8? (Choose all that apply)\n7: char[]c = new char[2];\n8: // INSERT CODE HERE",
        "explanation": "Arrays define a property called length. It is not a method, so parentheses are not allowed.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "int length = c.capacity;",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "int length = c.capacity();",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "int length = c.length;",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "int length = c.length();",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "int length = c.size;",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "int length = c.size();",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "None of the above.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 58,
        "chapterId": 2,
        "type": 2,
        "statement": "Which of these compile when replacing line 8? (Choose all that apply)\n7: ArrayList l = new ArrayList();\n8: // INSERT CODE HERE",
        "explanation": "The ArrayList class defines a method called size().",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "int length = l.capacity;",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "int length = l.capacity();",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "int length = l.length;",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "int length = l.length();",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "int length = l.size;",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "int length = l.size();",
            "isCorrect": true
          },
          {
            "id": 6,
            "answer": "None of the above.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 59,
        "chapterId": 2,
        "type": 2,
        "statement": "Which of the following are true? (Choose all that apply)",
        "explanation": "An array is not able to change size and can have multiple dimensions. Both an array and ArrayList are ordered and have indexes. Neither is immutable. The ele- ments can change in value.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "An array has a fixed size.",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "An ArrayList has a fixed size.",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "An array allows multiple dimensions.",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "An array is ordered.",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "An ArrayList is ordered.",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "An array is immutable.",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "An ArrayList is immutable.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 60,
        "chapterId": 2,
        "type": 2,
        "statement": "Which of the following are true? (Choose all that apply)",
        "explanation": "An array does not override equals() and so uses object equality. ArrayList does override equals() and defines it as the same elements in the same order. The compiler does not know when an index is out of bounds and thus can’t give you a compiler error. The code will throw an exception at runtime, though.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "Two arrays with the same content are equal.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "Two ArrayLists with the same content are equal.",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "If you call remove(0) using an empty ArrayList object, it will compile successfully.",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "If you call remove(0) using an empty ArrayList object, it will run successfully.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "None of the above.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 61,
        "chapterId": 2,
        "type": 1,
        "statement": "What is the result of the following statements?\n6: List<String> list = new ArrayList<String>(); 7: list.add(\"one\");\n8: list.add(\"two\");\n9: list.add(7);\n10: for(String s : list) System.out.print(s);",
        "explanation": "The code does not compile because list is instantiated using generics. Only String objects can be added to list and 7 is an int.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "onetwo",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "onetwo7",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "onetwo followed by an exception",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "Compiler error on line 9.",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "Compiler error on line 10.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 62,
        "chapterId": 2,
        "type": 1,
        "statement": "What is the result of the following statements?\n3: ArrayList<Integer> values = new ArrayList<>();4: values.add(4);\n5: values.add(5);\n6: values.set(1, 6);\n7: values.remove(0);\n8: for (Integer v : values) System.out.print(v);",
        "explanation": "After line 4, values has one element (4). After line 5, values has two elements (4, 5). After line 6, values has two elements (4, 6) because set() does a replace. After line 7, values has only one element (6).",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "4",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "5",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "6",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "46",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "45",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "An exception is thrown.",
            "isCorrect": true
          },
          {
            "id": 6,
            "answer": "The code does not compile.",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 63,
        "chapterId": 2,
        "type": 1,
        "statement": "What is the result of the following?\nint[] random = { 6, -4, 12, 0, -10 }; \nint x = 12;\nint y = Arrays.binarySearch(random, x); \nSystem.out.println(y);",
        "explanation": "The code compiles and runs fine. However, an array must be sorted for binarySe- arch() to return a meaningful result.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "2",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "4",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "6",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "The result is undefined.",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "An exception is thrown.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "The code does not compile.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 64,
        "chapterId": 2,
        "type": 1,
        "statement": "What is the result of the following?\n4: List<Integer> list = Arrays.asList(10, 4, -1, 5);\n5: Collections.sort(list);\n6: Integer array[] = list.toArray(new Integer[4]);\n7: System.out.println(array[0]);",
        "explanation": "Line 4 creates a fixed size array of size 4. Line 5 sorts it. Line 6 converts it back to an array. The brackets aren’t in the traditional place, but they are still legal. Line 7 prints the first element, which is now –1.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "-1",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "10",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "Compiler error on line 4.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "Compiler error on line 5.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "Compiler error on line 6.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "An exception is thrown.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 65,
        "chapterId": 2,
        "type": 1,
        "statement": "What is the result of the following?\n6: String [] names = {\"Tom\", \"Dick\", \"Harry\"};\n7: List<String> list = names.asList();\n8: list.set(0, \"Sue\");\n9: System.out.println(names[0]);",
        "explanation": "Converting from an array to an ArrayList uses Arrays.asList(names). There is no asList() method on an array instance. If this code were corrected to compile, the answer would be option A.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "Sue",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "Tom",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "Compiler error on line 7.",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "Compiler error on line 8.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "An exception is thrown.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 66,
        "chapterId": 2,
        "type": 1,
        "statement": "What is the result of the following?\nList<String> hex = Arrays.asList(\"30\", \"8\", \"3A\", \"FF\");\nCollections.sort(hex);\nint x = Collections.binarySearch(hex, \"8\");\nint y = Collections.binarySearch(hex, \"3A\");\nint z = Collections.binarySearch(hex, \"4F\");\nSystem.out.println(x + \" \" + y + \" \" + z);",
        "explanation": "After sorting, hex contains [30, 3A, 8, FF]. Remember that numbers sort before letters and strings sort alphabetically. This makes 30 come before 8. A binary search correctly finds 8 at index 2 and 3A at index 1. It cannot find 4F but notices it should be at index 2. The rule when an item isn’t found is to negate that index and subtract 1. Therefore, we get –2–1, which is –3.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "0 1 –2",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "0 1 –3",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "2 1 –2",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "2 1 –3",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "None of the above.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "The code doesn’t compile.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 67,
        "chapterId": 2,
        "type": 2,
        "statement": "Which of the following are true statements about the following code? (Choose all that apply)\n4: List<Integer> ages = new ArrayList<>();\n5: ages.add(Integer.parseInt(\"5\"));\n6: ages.add(Integer.valueOf(\"6\"));\n7: ages.add(7);\n8: ages.add(null);\n9: for (int age : ages) System.out.print(age);",
        "explanation": "Lines 5 and 7 use autoboxing to convert an int to an Integer. Line 6 does not because valueOf() returns an Integer. Line 8 does not because null is not an int. The code does not compile. However, when the for loop tries to unbox null into an int, it fails and throws a NullPointerException.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "The code compiles.",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "The code throws a runtime exception.",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "Exactly one of the add statements uses autoboxing.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "Exactly two of the add statements use autoboxing.",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "Exactly three of the add statements use autoboxing.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 68,
        "chapterId": 2,
        "type": 1,
        "statement": "What is the result of the following?\nList<String> one = new ArrayList<String>();\none.add(\"abc\");\nList<String> two = new ArrayList<>();\ntwo.add(\"abc\");\nif (one == two)\nSystem.out.println(\"A\");\nelse if (one.equals(two))\nSystem.out.println(\"B\"); else\nSystem.out.println(\"C\");",
        "explanation": "The first if statement is false because the variables do not point to the same object. The second if statement is true because ArrayList implements equality to mean the same elements in the same order.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "A",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "B",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "C",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "An exception is thrown.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "The code does not compile.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 69,
        "chapterId": 2,
        "type": 2,
        "statement": "Which of the following can be inserted into the blank to create a date of June 21, 2014? (Choose all that apply)\n\nimport java.time.*;\n\npublic class StartOfSummer {\n\n  public static void main(String[] args) { \n  LocalDate date = ____________________________ \n  }\n}",
        "explanation": "Options A and B are incorrect because LocalDate does not have a public con- structor. Option C is incorrect because months start counting with 1 rather than 0. Option E is incorrect because it uses the old pre–Java 8 way of counting months, again beginning with 0. Options D and F are both correct ways of specifying the desired date.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "new LocalDate(2014, 5, 21);",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "new LocalDate(2014, 6, 21);",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "LocalDate.of(2014, 5, 21);",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "LocalDate.of(2014, 6, 21);",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "LocalDate.of(2014, Calendar.JUNE, 21);",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "LocalDate.of(2014, Month.JUNE, 21);",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 70,
        "chapterId": 2,
        "type": 1,
        "statement": "What is the output of the following code?\nLocalDate date = LocalDate.parse(\"2018-04-30\", DateTimeFormatter.ISO_LOCAL_DATE);\ndate.plusDays(2);\ndate.plusHours(3);\nSystem.out.println(date.getYear() + \" \" + date.getMonth() + \" \" + date.getDayOfMonth());",
        "explanation": "A LocalDate does not have a time element. Therefore, it has no method to add hours and the code does not compile.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "2018 APRIL 2",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "2018 APRIL 30",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "2018 MAY 2",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "The code does not compile.",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "A runtime exception is thrown.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 71,
        "chapterId": 2,
        "type": 1,
        "statement": "What is the output of the following code? \nLocalDate date = LocalDate.of(2018, Month.APRIL, 40); \nSystem.out.println(date.getYear() + \" \" + date.getMonth() + \" \" + date.getDayOfMonth());",
        "explanation": "Java throws an exception if invalid date values are passed. There is no 40th day in April—or any other month for that matter.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "2018 APRIL 4",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "2018 APRIL 30",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "2018 MAY 10",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "Another date.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "The code does not compile.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "A runtime exception is thrown.",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 72,
        "chapterId": 2,
        "type": 1,
        "statement": "What is the output of the following code? \nLocalDate date = LocalDate.of(2018, Month.APRIL, 30); \ndate.plusDays(2); \ndate.plusYears(3); \nSystem.out.println(date.getYear() + \" \" + date.getMonth() + \" \" + date.getDayOfMonth());",
        "explanation": "The date starts out as April 30,2018. Since dates are immutable and the plus meth - ods have their return values ignored, the result is unchanged. Therefore, option B is correct.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "2018 APRIL 2",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "2018 APRIL 30",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "2018 MAY 2",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "2021 APRIL 2",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "2021 APRIL 30",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "2021 MAY 2",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "A runtime exception is thrown.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 73,
        "chapterId": 2,
        "type": 1,
        "statement": "What is the output of the following code?\nLocalDateTime d = LocalDateTime.of(2015, 5, 10, 11, 22, 33);\nPeriod p = Period.of(1, 2, 3);\nd = d.minus(p);\nDateTimeFormatter f = DateTimeFormatter.ofLocalizedTime(FormatStyle.SHORT);\nSystem.out.println(d.format(f));",
        "explanation": "Even though d has both date and time, the formatter only outputs time.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "3/7/14 11:22 AM",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "5/10/15 11:22 AM",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "3/7/14",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "5/10/15",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "11:22 AM",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "The code does not compile.",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "A runtime exception is thrown.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 74,
        "chapterId": 2,
        "type": 1,
        "statement": "What is the output of the following code?\nLocalDateTime d = LocalDateTime.of(2015, 5, 10, 11, 22, 33);\nPeriod p = Period.ofDays(1).ofYears(2);\nd = d.minus(p);\nDateTimeFormatter f = DateTimeFormatter.ofLocalizedDateTime(FormatStyle .SHORT);\nSystem.out.println(f.format(d));",
        "explanation": "Period does not allow chaining. Only the last Period method called counts, so only the two years are subtracted.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "5/9/13 11:22 AM",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "5/10/13 11:22 AM",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "5/9/14",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "5/10/14",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "The code does not compile.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "A runtime exception is thrown.",
            "isCorrect": false
          }
        ]
      }
    ]
  },
  {
    "id": 3,
    "color": "#8E44AD",
    "name": "Methods and Encapsulation",
    "questions": [
      {
        "id": 75,
        "chapterId": 3,
        "type": 2,
        "statement": "Which of the following can fill in the blank in this code to make it compile? (Choose all that apply)\npublic class Ant {\n _____ void method() { }\n}",
        "explanation": "void is a return type. Only the access modifier or optional specifiers are allowed before the return type. Option C is correct, creating a method with private access. Option B is correct, creating a method with default access and the optional specifier final. Since default access does not require a modifier, we get to jump right to final.\nOption A is incorrect because default access omits the access modifier rather than spec- ifying default. Option D is incorrect because Java is case sensitive. It would have been correct if public were the choice. Option E is incorrect because the method already has a void return type. Option F is incorrect because labels are not allowed for methods.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "default",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "final",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "private",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "Public",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "String",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "zzz:",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 76,
        "chapterId": 3,
        "type": 2,
        "statement": "Which of the following compile? (Choose all that apply)",
        "explanation": "Options A and D are correct because the optional specifiers are allowed in any order. Options B and C are incorrect because they each have two return types. Options E and F are incorrect because the return type is before the optional specifier and access modifier, respectively.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "final static void method4() { }",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "public final int void method() { }",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "private void int method() { }",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "static final void method3() { }",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "void final method() {}",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "void public method() { }",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 77,
        "chapterId": 3,
        "type": 2,
        "statement": "Which of the following methods compile? (Choose all that apply)",
        "explanation": "Options A and C are correct because a void method is allowed to have a return statement as long as it doesn’t try to return a value. Options B and G do not compile because null requires a reference object as the return type. void is not a refer- ence object since it is a marker for no return type. int is not a reference object since it is a primitive. Option D is correct because it returns an int value. Option E does not compile because it tries to return a double when the return type is int. Since a double cannot be assigned to an int, it cannot be returned as one either. Option F does not compile because no value is actually returned.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "public void methodA() { return;}",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "public void methodB() { return null;}",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "public void methodD() {}",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "public int methodD() { return 9;}",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "public int methodE() { return 9.0;}",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "public int methodF() { return;}",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "public int methodG() { return null;}",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 78,
        "chapterId": 3,
        "type": 2,
        "statement": "Which of the following compile? (Choose all that apply)",
        "explanation": "Options A and B are correct because the single vararg parameter is the last parameter declared. Option G is correct because it doesn’t use any vararg parameters at all. Options C and F are incorrect because the vararg parameter is not last. Option D is incorrect because two vararg parameters are not allowed in the same method. Option E is incorrect because the ... for a vararg must be after the type, not before it.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "public void moreA(int... nums) {}",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "public void moreB(String values, int... nums) {}",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "public void moreC(int... nums, String values) {}",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "public void moreD(String... values, int... nums) {}",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "public void moreE(String[] values, ...int nums) {}",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "public void moreF(String... values, int[] nums) {}",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "public void moreG(String[] values, int[] nums) {}",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 79,
        "chapterId": 3,
        "type": 2,
        "statement": "Given the following method, which of the method calls return 2? (Choose all that apply) \npublic int howMany(boolean b, boolean... b2) {\n  return b2.length; \n}",
        "explanation": "Option D passes the initial parameter plus two more to turn into a vararg array of size 2. Option G passes the initial parameter plus an array of size 2. Option A does not compile because it does not pass the initial parameter. Options E and F do not compile because they do not declare an array properly. It should be new boolean[] {true}. Option B creates a vararg array of size 0 and option C creates a vararg array of size 1.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "howMany();",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "howMany(true);",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "howMany(true, true);",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "howMany(true, true, true);",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "howMany(true, {true});",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "howMany(true, {true, true});",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "howMany(true, new boolean[2]);",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 80,
        "chapterId": 3,
        "type": 2,
        "statement": "Which of the following are true? (Choose all that apply)",
        "explanation": "Option D is correct. This is the common implementation for encapsulation by set- ting all fields to be private and all methods to be public. Option A is incorrect because protected access allows everything that package private access allows and additionally allows subclasses access. Option B is incorrect because the class is public. This means that other classes can see the class. However, they cannot call any of the methods or read any of the fields. It is essentially a useless class. Option C is incorrect because package private access applies to the whole package. Option E is incorrect because Java has no such capability.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "Package private access is more lenient than protected access.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "A public class that has private fields and package private methods is not visible to classes outside the package.",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "You can use access modifiers so only some of the classes in a package see a particular package private class.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "You can use access modifiers to allow read access to all methods, but not any instance variables.",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "You can use access modifiers to restrict read access to all classes that begin with the word Test.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 81,
        "chapterId": 3,
        "type": 2,
        "statement": "Given the following my.school.ClassRoom and my.city.School class definitions, which line numbers in main() generate a compiler error? (Choose all that apply)\n1: package my.school;\n2: public class Classroom {\n3:   private int roomNumber;\n4:   protected String teacherName;\n5:   static int globalKey = 54321;\n6:   public int floor = 3;\n7:   Classroom(int r, String t) {\n8:     roomNumber = r;\n9:     teacherName = t; } }\n\n1: package my.city;\n2: import my.school.*;\n3: public class School {\n4: public static void main(String[] args) {\n5:   System.out.println(Classroom.globalKey);\n6:   Classroom room = new Classroom(101, \"\"Mrs. Anderson\");\n7:   System.out.println(room.roomNumber);\n8:   System.out.println(room.floor);\n9:   System.out.println(room.teacherName); } }",
        "explanation": "The two classes are in different packages, which means private access and default (package private) access will not compile. Additionally, protected access will not compile since School does not inherit from Classroom. Therefore, only line 8 will compile because it uses public access.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "None, the code compiles fine.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "Line 5",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "Line 6",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "Line 7",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "Line 8",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "Line 9",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 82,
        "chapterId": 3,
        "type": 2,
        "statement": "Which of the following are true? (Choose all that apply)",
        "explanation": "Encapsulation requires using methods to get and set instance variables so other classes are not directly using them. Instance variables must be private for this to work. Immutability takes this a step further, allowing only getters, so the instance variables do not change state.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "Encapsulation uses package private instance variables.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "Encapsulation uses private instance variables.",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "Encapsulation allows setters.",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "Immutability uses package private instance variables.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "Immutability uses private instance variables.",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "Immutability allows setters.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 83,
        "chapterId": 3,
        "type": 2,
        "statement": "Which are methods using JavaBeans naming conventions for accessors and mutators? (Choose all that apply)",
        "explanation": "Option A is incorrect because the property is of type boolean and getters must begin with is for booleans. Options B and D are incorrect because they don’t follow the naming convention of beginning with get/is/set. Options C and E follow normal getter and setter conventions.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "public boolean getCanSwim() { return canSwim;}",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "public boolean canSwim() { return numberWings;}",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "public int getNumWings() { return numberWings;}",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "public int numWings() { return numberWings;}",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "public void setCanSwim(boolean b) { canSwim = b;}",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 84,
        "chapterId": 3,
        "type": 1,
        "statement": "What is the output of the following code?\n1: package rope;\n2: public class Rope {\n3:   public static int LENGTH = 5;\n4:   static {\n5:     LENGTH = 10; \n6:   }\n7:   public static void swing() { \n8:     System.out.print(\"swing\"); \n9:   }\n10: }\n\n1: import rope.*;\n2: import static rope.Rope.*;\n3: public class Chimp {\n4:   public static void main(String[] args) {\n5:     Rope.swing();\n6:     new Rope().swing();\n7:     System.out.println(LENGTH);\n8:   }\n9: }",
        "explanation": "Rope runs line 3, setting LENGTH to 5, then immediately after runs the static initial- izer, which sets it to 10. Line 5 calls the static method normally and prints swing. Line 6 also calls the static method. Java allows calling a static method through an instance variable. Line 7 uses the static import on line 2 to reference LENGTH.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "swing swing 5",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "swing swing 10",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "Compiler error on line 2 of Chimp.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "Compiler error on line 5 of Chimp.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "Compiler error on line 6 of Chimp.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "Compiler error on line 7 of Chimp.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 85,
        "chapterId": 3,
        "type": 2,
        "statement": "Which are true of the following code? (Choose all that apply)\n1: public class Rope {\n2:   public static void swing() {\n3:     System.out.print(\"swing\"); \n4:  }\n5:  public void climb() {\n6:    System.out.println(\"climb \");\n7:  }\n8:  public static void play() {\n9:    swing();\n10:  climb(); \n11: }\n12: public static void main(String[] args) {\n13:   Rope rope = new Rope();\n14:   rope.play();\n15:   Rope rope2 = null;\n16:   rope2.play();\n17:  }\n18: }",
        "explanation": "Line 10 does not compile because static methods are not allowed to call instance methods. Even though we are calling play() as if it were an instance method and an instance exists, Java knows play() is really a static method and treats it as such. If line 10 is removed, the code works. It does not throw a NullPointerException on line 16 because play() is a static method. Java looks at the type of the reference for rope2 and translates the call to Rope.play().",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "The code compiles as is.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "There is exactly one compiler error in the code.",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "There are exactly two compiler errors in the code.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "If the lines with compiler errors are removed, the output is climb climb.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "If the lines with compiler errors are removed, the output is swing swing.",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "If the lines with compile errors are removed, the code throws a NullPointerException.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 86,
        "chapterId": 3,
        "type": 1,
        "statement": "What is the output of the following code? import rope.*;\nimport static rope.Rope.*;\npublic class RopeSwing {\n  private static Rope rope1 = new Rope();\n  private static Rope rope2 = new Rope(); {\n   System.out.println(rope1.length); \n }public static void main(String[] args) { \n  rope1.length = 2;\n  rope2.length = 8;\n  System.out.println(rope1.length);\n  }\n}\n\npackage rope;\npublic class Rope {\npublic static int length = 0;\n}",
        "explanation": "There are two details to notice in this code. First, note that RopeSwing has an instance initializer and not a static initializer. Since RopeSwing is never constructed, the instance initializer does not run. The other detail is that length is static. Changes from one object update this common static variable.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "02",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "08",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "2",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "8",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "The code does not compile.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "An exception is thrown.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 87,
        "chapterId": 3,
        "type": 1,
        "statement": "How many compiler errors are in the following code?\n1: public class RopeSwing {\n2:  private static final String leftRope;\n3:  private static final String rightRope;\n4:  private static final String bench;\n5:  private static final String name = \"name\";\n6:  static {\n7:    leftRope = \"left\";\n8:    rightRope = \"right\";\n9: }\n10: static {\n11:   name = \"name\";\n12:   rightRope = \"right\";\n13: }\n14: public static void main(String[] args) {\n15:   bench = \"bench\";\n16: }\n17: }",
        "explanation": "static final variables must be set exactly once, and it must be in the declaration line or in a static initialization block. Line 4 doesn’t compile because bench is not set in either of these locations. Line 15 doesn’t compile because final variables are not allowed to be set after that point. Line 11 doesn’t compile because name is set twice: once in the declaration and again in the static block. Line 12 doesn’t compile because rightRope is set twice as well. Both are in static initialization blocks.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "0",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "1",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "2",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "3",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "4",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "5",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 88,
        "chapterId": 3,
        "type": 2,
        "statement": "Which of the following can replace line 2 to make this code compile? (Choose all that apply)\n1: import java.util.*;\n2: // INSERT CODE HERE\n3: public class Imports {\n4:  public void method(ArrayList<String> list) {\n5:   sort(list);\n6:  }\n7: }",
        "explanation": "The two valid ways to do this are import static java.util.Collections.*; and import static java.util.Collections.sort;. Option A is incorrect because you can only do a static import on static members. Classes such as Collections require a regular import. Option C is nonsense as method parameters have no business in an import. Options D, E, and F try to trick you into reversing the syntax of import static.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "import static java.util.Collections;",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "import static java.util.Collections.*;",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "import static java.util.Collections.sort(ArrayList<String>);",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "static import java.util.Collections;",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "static import java.util.Collections.*;",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "static import java.util.Collections.sort(ArrayList<String>);",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 89,
        "chapterId": 3,
        "type": 1,
        "statement": "What is the result of the following statements?\n1: public class Test {\n2:   public void print(byte x) {\n3:     System.out.print(\"byte\");\n4:   }\n5:   public void print(int x) {\n6:     System.out.print(\"int\");\n7:   }\n8:   public void print(float x) {\n9:     System.out.print(\"float\");\n10:  }\n11:  public void print(Object x) {\n12:    System.out.print(\"Object\");\n13:  }\n14:  public static void main(String[] args) {\n15:    Test t = new Test();\n16:    short s = 123;\n17:    t.print(s);\n18:    t.print(true);\n19:    t.print(6.789);\n20:   }\n21: }",
        "explanation": "The argument on line 17 is a short. It can be promoted to an int, so print() on line 5 is invoked. The argument on line 18 is a boolean. It can be autoboxed to a bool- ean, so print() on line 11 is invoked. The argument on line 19 is a double. It can be autoboxed to a double, so print() on line 11 is invoked. Therefore, the output is intObjectObject and the correct answer is option E.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "bytefloatObject",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "intfloatObject",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "byteObjectfloat",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "intObjectfloat",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "intObjectObject",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "byteObjectObject",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 90,
        "chapterId": 3,
        "type": 1,
        "statement": "What is the result of the following program?\n1: public class Squares {\n2:   public static long square(int x) {\n3:     long y = x * (long) x;\n4:     x = -1;\n5:     return y;\n6:   }\n7:   public static void main(String[] args) {\n8:     int value = 9;\n9:     long result = square(value);\n10:    System.out.println(value);\n11: } }",
        "explanation": "Since Java is pass-by-value and the variable on line 8 never gets reassigned, it stays as 9. In the method square, x starts as 9. y becomes 81 and then x gets set to –1. Line 9 does set result to 81. However, we are printing out value and that is still 9.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "-1",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "9",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "81",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "Compiler error on line 9.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "Compiler error on a different line.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 91,
        "chapterId": 3,
        "type": 2,
        "statement": "Which of the following are output by the following code? (Choose all that apply) \npublic class StringBuilders {\n  public static StringBuilder work(StringBuilder a, StringBuilder b) {\n    a = new StringBuilder(\"a\"); b.append(\"b\");\n    return a;\n  }\n  public static void main(String[] args) {\n    StringBuilder s1 = new StringBuilder(\"s1\"); \n    StringBuilder s2 = new StringBuilder(\"s2\"); \n    StringBuilder s3 = work(s1, s2); \n    System.out.println(\"s1 = \" + s1); \n    System.out.println(\"s2 = \" + s2); \n    System.out.println(\"s3 = \" + s3);\n  } }",
        "explanation": "Since Java is pass-by-reference, assigning a new object to a does not change the caller. Calling append() does affect the caller because both the method parameter and caller have a reference to the same object. Finally, returning a value does pass the refer- ence to the caller for assignment to s3.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "s1 = a",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "s1 = s1",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "s2 = s2",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "s2 = s2b",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "s3 = a",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "s3 = null",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "The code does not compile.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 92,
        "chapterId": 3,
        "type": 2,
        "statement": "Which of the following are true? (Choose 2)",
        "explanation": "Since the main() method is in the same class, it can call private methods in the class. this() may only be called as the first line of a constructor. this.variableName can be called from any instance method to refer to an instance variable. It cannot be called from a static method because there is no instance of the class to refer to. Option F is tricky. The default constructor is only written by the compiler if no user-defined constructors were provided. this() can only be called from a constructor in the same class. Since there can be no user-defined constructors in the class if a default construc- tor was created, it is impossible for option F to be true.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "this() can be called from anywhere in a constructor.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "this() can be called from any instance method in the class.",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "this.variableName can be called from any instance method in the class.",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "this.variableName can be called from any static method in the class.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "You must include a default constructor in the code if the compiler does not include one.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "You can call the default constructor written by the compiler using this().",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "You can access a private constructor with the main() method.",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 93,
        "chapterId": 3,
        "type": 2,
        "statement": "Which of these classes compile and use a default constructor? (Choose all that apply)",
        "explanation": "Options B and C don’t compile because the constructor name must match the classname. Since Java is case sensitive, these don’t match. Options D, E, and F all com- pile and provide one user-defined constructor. Since a constructor is coded, a default constructor isn’t supplied. Option G defines a method, but not a constructor. Option A does not define a constructor, either. Since no constructor is coded, a default construc- tor is provided for options A and G.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "public class Bird { }",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "public class Bird { public bird() {} }",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "public class Bird { public bird(String name) {} }",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "public class Bird { public Bird() {} }",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "public class Bird { Bird(String name) {} }",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "public class Bird { private Bird(int age) {} }",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "public class Bird { void Bird() { }",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 94,
        "chapterId": 3,
        "type": 1,
        "statement": "Which code can be inserted to have the code print 2? public class BirdSeed {\n  private int numberBags; \n  boolean call;\n\n  public BirdSeed() { \n    // LINE 1\n    call = false;\n    // LINE 2\n  }\n  public BirdSeed(int numberBags) {\n    this.numberBags = numberBags;\n  }\n  public static void main(String[] args) {\n BirdSeed seed = new BirdSeed();\n    System.out.println(seed.numberBags);\n  } }",
        "explanation": "Options A and B will not compile because constructors cannot be called without new. Options C and D will compile but will create a new object rather than setting the fields in this one. Option F will not compile because this() must be the first line of a constructor. Option E is correct.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "Replace line 1 with BirdSeed(2);",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "Replace line 2 with BirdSeed(2);",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "Replace line 1 with new BirdSeed(2);",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "Replace line 2 with new BirdSeed(2);",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "Replace line 1 with this(2);",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "Replace line 2 with this(2);",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 95,
        "chapterId": 3,
        "type": 2,
        "statement": "Whichofthefollowingcompletetheconstructorsothatthiscodeprintsout50?(Choose all that apply)public class Cheetah {\n  int numSpots;\n  public Cheetah(int numSpots) {\n    // INSERT CODE HERE\n  }\n  public static void main(String[] args) {\n System.out.println(new Cheetah(50).numSpots);\n  } }",
        "explanation": "Within the constructor numSpots refers to the constructor parameter.The instance variable is hidden because they have the same name. this.numSpots tells Java to use the instance variable. In the main() method, numSpots refers to the instance variable. Option A sets the constructor parameter to itself, leaving the instance variable as 0. Option B sets the constructor parameter to the value of the instance variable, making them both 0. Option C is correct, setting the instance variable to the value of the con- structor parameter. Options D and E do not compile.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "numSpots = numSpots;",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "numSpots = this.numSpots;",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "this.numSpots = numSpots;",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "numSpots = super.numSpots;",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "super.numSpots = numSpots;",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "None of the above.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 96,
        "chapterId": 3,
        "type": 1,
        "statement": "What is the result of the following?\n1: public class Order {\n2: static String result = \"\";\n3: { result += \"c\"; }\n4: static\n5: { result += \"u\"; }\n6: { result += \"r\"; }\n7: }\n\n1: public class OrderDriver {\n2: public static void main(String[] args) {\n3: System.out.print(Order.result + \" \");\n4: System.out.print(Order.result + \" \");v5: new Order();v6: new Order();\n7: System.out.print(Order.result + \" \");\n8: }\n9: }",
        "explanation": "On line 3 of OrderDriver, we refer to Order for the first time. At this point the stat- ics in Order get initialized. In this case, the statics are the static declaration of result and the static initializer. result is u at this point. On line 4, result is the same because the static initialization is only run once. On line 5, we create a new Order, which triggers the instance initializers in the order they appear in the file. Now result is ucr. Line 6 creates another Order, triggering another set of initializers. Now result is ucrcr. Notice how the static is on a different line than the initialization code in lines 4–5 of Order. The exam may try to trick you by formatting the code like this to confuse you.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "curur",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "ucrcr",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "u ucrcr",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "u u curcur",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "u u ucrcr",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "ur ur urc",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "The code does not compile.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 97,
        "chapterId": 3,
        "type": 1,
        "statement": "What is the result of the following?\n1: public class Order {\n2:   String value = \"t\";\n3:   { value += \"a\"; }\n4:   { value += \"c\"; }\n5:   public Order() {\n6:   value += \"b\";\n7:   }\n8:   public Order(String s) {\n9:     value += s;\n10:  }\n11:  public static void main(String[] args) {\n12:    Order order = new Order(\"f\");\n13:    order = new Order();\n14:    System.out.println(order.value);\n15: } }",
        "explanation": "Line 4 instantiates an Order. Java runs the declarations and instance initializers first in the order they appear. This sets value to tacf. Line 5 creates another Order and initializes value to tacb. The object on line 5 is stored in the same variable line 4 used. This makes the object created on line 4 unreachable. When value is printed, it is the instance variable in the object created on line 5.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "tacb",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "tacf",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "tacbf",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "tacfb",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "tacftacb",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "The code does not compile.",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "An exception is thrown.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 98,
        "chapterId": 3,
        "type": 2,
        "statement": "Which of the following will compile when inserted in the following code? (Choose all that apply)\npublic class Order3 {\n  final String value1 = \"1\";\n  static String value2 = \"2\";\n  String value3 = \"3\";\n  {\n    // CODE SNIPPET 1\n  }\n  static {\n    // CODE SNIPPET 2\n  }\n }",
        "explanation": "value1 is a final instance variable. It can only be set once: in the variable dec- laration, an instance initializer, or a constructor. Option A does not compile because the final variable was already set in the declaration. value2 is a static variable. Both instance and static initializers are able to access static variables, making options B and E correct. value3 is an instance variable. Options D and F do not compile because a static initializer does not have access to instance variables.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "value1 = \"d\"; instead of // CODE SNIPPET 1",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "value2 = \"e\"; instead of // CODE SNIPPET 1",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "value3 = \"f\"; instead of // CODE SNIPPET 1",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "value1 = \"g\"; instead of // CODE SNIPPET 2",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "value2 = \"h\"; instead of // CODE SNIPPET 2",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "value3 = \"i\"; instead of // CODE SNIPPET 2",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 99,
        "chapterId": 3,
        "type": 2,
        "statement": "Which of the following are true about the following code? (Choose all that apply) \npublic class Create {\n  Create() {\n    System.out.print(\"1 \");\n  }\n  Create(int num) {\n    System.out.print(\"2 \");\n  }\n  Create(Integer num) {\n     System.out.print(\"3 \");\n  }\n  Create(Object num) {\n    System.out.print(\"4 \");\n   }\n  Create(int... nums) {\n     System.out.print(\"5 \");\n  }\n  public static void main(String[] args) {\n    new Create(100);\n    new Create(1000L);\n   }\n}",
        "explanation": "The 100 parameter is an int and so calls the matching int constructor. When this constructor is removed, Java looks for the next most specific constructor. Java pre- fers autoboxing to varargs, and so chooses the Integer constructor. The 100L param- eter is a long. Since it can’t be converted into a smaller type, it is autoboxed into a Long and then the constructor for Object is called.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "The code prints out 2 4.",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "The code prints out 3 4.",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "The code prints out 4 2.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "The code prints out 4 4.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "The code prints 3 4 if you remove the constructor Create(int num).",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "The code prints 4 4 if you remove the constructor Create(int num).",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "The code prints 5 4 if you remove the constructor Create(int num).",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 100,
        "chapterId": 3,
        "type": 1,
        "statement": "What is the result of the following class?\n1: import java.util.function.*;\n2:\n3: public class Panda {\n4:   int age;\n5:   public static void main(String[] args) {\n6:     Panda p1 = new Panda();\n7:     p1.age = 1;\n8:     check(p1, p -> p.age < 5);\n9:   }\n10:  private static void check(Panda panda, Predicate<Panda> pred) {\n11:    String result = pred.test(panda) ? \"match\" : \"not match\";\n12:    System.out.print(result);\n13: } }",
        "explanation": "This code is correct. Line 8 creates a lambda expression that checks if the age is less than 5. Since there is only one parameter and it does not specify a type, the parentheses around the type parameter are optional. Line 10 uses the Predicate interface, which declares a test() method.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "match",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "not match",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "Compiler error on line 8.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "Compiler error on line 10.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "Compiler error on line 11.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "A runtime exception is thrown.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 101,
        "chapterId": 3,
        "type": 1,
        "statement": "What is the result of the following code?\n1: interface Climb {\n2:   boolean isTooHigh(int height, int limit);\n3: }\n4:\n5: public class Climber {\n6:   public static void main(String[] args) {\n7:   check((h, l) -> h.append(l).isEmpty(), 5);\n8:   }\n9:   private static void check(Climb climb, int height) {\n10:     if (climb.isTooHigh(height, 10))\n11:       System.out.println(\"too high\");\n12:     else\n13:       System.out.println(\"ok\");\n14:   }\n15: }",
        "explanation": "The interface takes two int parameters. The code on line 7 attempts to use them as if one is a StringBuilder. It is tricky to use types in a lambda when they are implicitly specified. Remember to check the interface for the real type.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "ok",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "too high",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "Compiler error on line 7.",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "Compiler error on line 10.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "Compiler error on a different line.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "A runtime exception is thrown.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 102,
        "chapterId": 3,
        "type": 2,
        "statement": "Which of the following lambda expressions can fill in the blank? (Choose all that apply)\n List<String> list = new ArrayList<>();\nlist.removeIf(___________________);",
        "explanation": "removeIf() expects a Predicate, which takes a parameter list of one param- eter using the specified type. Options B and C are incorrect because they do not use the return keyword. It is required inside braces for lambda bodies. Option E is incorrect because it is missing the parentheses around the parameter list. This is only optional for a single parameter with an inferred type.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "s -> s.isEmpty()",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "s -> {s.isEmpty()}",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "s -> {s.isEmpty();}",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "s -> {return s.isEmpty();}",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "String s -> s.isEmpty()",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "(String s) -> s.isEmpty()",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 103,
        "chapterId": 3,
        "type": 2,
        "statement": "Which lambda can replace the MySecret class to return the same value? (Choose all that apply)\ninterface Secret {\n  String magic(double d);\n}\n\nclass MySecret implements Secret {\n  public String magic(double d) {\n    return \"Poof\";\n  }\n}",
        "explanation": "Option B is incorrect because it does not use the return keyword. Options C, D, and E are incorrect because the variable e is already in use from the lambda and can- not be redefined. Additionally, option C is missing the return keyword and option E is missing the semicolon.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "caller((e) -> \"Poof\");",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "caller((e) -> {\"Poof\"});",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "caller((e) -> { String e = \"\"; \"Poof\" });",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "caller((e) -> { String e = \"\"; return \"Poof\"; });",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "caller((e) -> { String e = \"\"; return \"Poof\" });",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "caller((e) -> { String f = \"\"; return \"Poof\"; });",
            "isCorrect": true
          }
        ]
      }
    ]
  },
  {
    "id": 4,
    "color": "#2C3E50",
    "name": "Class Design",
    "questions": [
      {
        "id": 104,
        "chapterId": 4,
        "type": 2,
        "statement": "What modifiers are implicitly applied to all interface methods? (Choose all that apply)",
        "explanation": "All interface methods are implicitly public, so option B is correct and option A is not. Interface methods may be declared as static or default but are never implicitly added, so options C and F are incorrect. Option D is incorrect—void is not a modifier; it is a return type. Option E is a tricky one, because prior to Java 8 all interface meth- ods would be assumed to be abstract. Since Java 8 now includes default and static methods and they are never abstract, you cannot assume the abstract modifier will be implicitly applied to all methods by the compiler.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "protected",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "public",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "static",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "void",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "abstract",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "default",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 105,
        "chapterId": 4,
        "type": 1,
        "statement": "What is the output of the following code?\n1: class Mammal {\n2:   public Mammal(int age) {\n3:     System.out.print(\"Mammal\");\n4:   }\n5: }\n6: public class Platypus extends Mammal {\n7:   public Platypus() {\n8:     System.out.print(\"Platypus\");\n9:   }\n10:  public static void main(String[] args) {\n11:    new Mammal(5);\n12:  }\n13: }",
        "explanation": "The code will not compile because the parent class Mammal doesn’t define a no-argu- ment constructor, so the first line of a Platypus constructor should be an explicit call to super(int age). If there was such a call, then the output would be MammalPlatypus, since the super constructor is executed before the child constructor.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "Platypus",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "Mammal",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "PlatypusMammal",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "MammalPlatypus",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "The code will not compile because of line 8.",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "The code will not compile because of line 11.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 106,
        "chapterId": 4,
        "type": 2,
        "statement": "Which of the following statements can be inserted in the blank line so that the code will compile successfully? (Choose all that apply)\npublic interface CanHop {}\npublic class Frog implements CanHop {\n  public static void main(String[] args) {\n    __________ frog = new TurtleFrog();\n  }\n}\npublic class BrazilianHornedFrog extends Frog {}\npublic class TurtleFrog extends Frog {}",
        "explanation": "The blank can be filled with any class or interface that is a supertype of TurtleFrog. Option A is a superclass of TurtleFrog, and option B is the same class, so both are correct. BrazilianHornedFrog is not a superclass of TurtleFrog, so option C is incorrect. TurtleFrog inherits the CanHope interface, so option D is correct. All classes inherit Object, so option E is correct. Finally, Long is an unrelated class that is not a superclass of TurtleFrog, and is therefore incorrect.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "Frog",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "TurtleFrog",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "BrazilianHornedFrog",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "CanHop",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "Object",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "Long",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 107,
        "chapterId": 4,
        "type": 2,
        "statement": "Which statement(s) are correct about the following code? (Choose all that apply)\npublic class Rodent {\n  protected static Integer chew() throws Exception {\n    System.out.println(\"Rodent is chewing\");\n    return 1;\n  }\n}\npublic class Beaver extends Rodent {\n  public Number chew() throws RuntimeException {\n    System.out.println(\"Beaver is chewing on wood\");\n    return 2;\n  }\n}",
        "explanation": "The code doesn’t compile, so option A is incorrect. Option B is also not correct because the rules for overriding a method allow a subclass to define a method with an exception that is a subclass of the exception in the parent method. Option C is cor- rect because the return types are not covariant; in particular, Number is not a subclass of Integer. Option D is incorrect because the subclass defines a method that is more accessible than the method in the parent class, which is allowed. Finally, option E is correct because the method is declared as static in the parent class and not so in the child class. For nonprivate methods in the parent class, both methods must use static (hide) or neither should use static (override).",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "It will compile without issue.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "It fails to compile because the type of the exception the method throws is a subclass of the type of exception the parent method throws.",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "It fails to compile because the return types are not covariant.",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "It fails to compile because the method is protected in the parent class and public in the subclass.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "It fails to compile because of a static modifier mismatch between the two methods.",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 108,
        "chapterId": 4,
        "type": 2,
        "statement": "Which of the following may only be hidden and not overridden? (Choose all that apply)",
        "explanation": "First off, options B and C are incorrect because protected and public meth- ods may be overridden, not hidden. Option A is correct because private methods are always hidden in a subclass. Option D is also correct because static methods cannot be overridden, only hidden. Options E and F are correct because variables may only be hidden, regardless of the access modifier.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "private instance methods",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "protected instance methods",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "public instance methods",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "static methods",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "public variables",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "private variables",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 109,
        "chapterId": 4,
        "type": 1,
        "statement": "Choose the correct statement about the following code:\n1: interface HasExoskeleton {\n2: abstract int getNumberOfSections();\n3: }\n4: abstract class Insect implements HasExoskeleton {\n5: abstract int getNumberOfLegs();\n6: }\n7: public class Beetle extends Insect {\n8: int getNumberOfLegs() { return 6; }\n9: }",
        "explanation": "The code fails to compile because Beetle, the first concrete subclass, doesn’t imple- ment getNumberOfSections(), which is inherited as an abstract method; therefore, option D is correct. Option B is incorrect because there is nothing wrong with this interface method definition. Option C is incorrect because an abstract class is not required to implement any abstract methods, including those inherited from an inter- face. Option E is incorrect because the code fails at compilation-time.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "It compiles and runs without issue.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "The code will not compile because of line 2.",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "The code will not compile because of line 4.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "The code will not compile because of line 7.",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "It compiles but throws an exception at runtime.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 110,
        "chapterId": 4,
        "type": 2,
        "statement": "Which of the following statements about polymorphism are true? (Choose all that apply)",
        "explanation": "A reference to an object requires an explicit cast if referenced with a subclass, so option A is incorrect. If the cast is to a superclass reference, then an explicit cast is not required. Because of polymorphic parameters, if a method takes the superclass of an object as a parameter, then any subclass references may be used without a cast, so option B is correct. All objects extend java.lang.Object, so if a method takes that type, any valid object, including null, may be passed; therefore, option C is correct. Some cast exceptions can be detected as errors at compile-time, but others can only be detected at runtime, so D is incorrect. Due to the nature of polymorphism, a public instance method can be overridden in a subclass and calls to it will be replaced even in the superclass it was defined, so E is incorrect.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "A reference to an object may be cast to a subclass of the object without an explicit cast.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "If a method takes a superclass of three objects, then any of those classes may be passed as a parameter to the method.",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "A method that takes a parameter with type java.lang.Object will take any reference.",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "All cast exceptions can be detected at compile-time.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "By defining a public instance method in the superclass, you guarantee that the specific method will be called in the parent class at runtime.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 111,
        "chapterId": 4,
        "type": 1,
        "statement": "Choose the correct statement about the following code:\n1: public interface Herbivore {\n2:   int amount = 10;\n3:   public static void eatGrass();\n4:   public int chew() {\n5:     return 13;\n6:   }\n7: }",
        "explanation": "The interface variable amount is correctly declared, with public and static being assumed and automatically inserted by the compiler, so option B is incorrect. The method declaration for eatGrass() on line 3 is incorrect because the method has been marked as static but no method body has been provided. The method declaration for chew() on line 4 is also incorrect, since an interface method that provides a body must be marked as default or static explicitly. Therefore, option F is the correct answer since this code contains two compile-time errors.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "It compiles and runs without issue.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "The code will not compile because of line 2.",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "The code will not compile because of line 3.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "The code will not compile because of line 4.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "The code will not compile because of lines 2 and 3.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "The code will not compile because of lines 3 and 4.",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 112,
        "chapterId": 4,
        "type": 1,
        "statement": "Choose the correct statement about the following code:\n1: public interface CanFly {\n2:   void fly();\n3: }\n4: interface HasWings {\n5:   public abstract Object getWindSpan();\n6: }\n7: abstract class Falcon implements CanFly, HasWings {\n8: }",
        "explanation": "Although the definition of methods on lines 2 and 5 vary, both will be converted to public abstract by the compiler. Line 4 is fine, because an interface can have pub- lic or default access. Finally, the class Falcon doesn’t need to implement the interface methods because it is marked as abstract. Therefore, the code will compile without issue.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "It compiles without issue.",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "The code will not compile because of line 2.",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "The code will not compile because of line 4.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "The code will not compile because of line 5.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "The code will not compile because of lines 2 and 5.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "The code will not compile because the class Falcon doesn’t implement the interface methods.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 113,
        "chapterId": 4,
        "type": 2,
        "statement": "Which statements are true for both abstract classes and interfaces? (Choose all that apply)",
        "explanation": "Option A is wrong, because an abstract class may contain concrete meth- ods. Since Java 8, interfaces may also contain concrete methods in form of static or default methods. Although all variables in interfaces are assumed to be public static final, abstract classes may contain them as well, so option B is correct. Both abstract classes and interfaces can be extended with the extends keyword, so option C is cor- rect. Only interfaces can contain default methods, so option D is incorrect. Both abstract classes and interfaces can contain static methods, so option E is correct. Both structures require a concrete subclass to be instantiated, so option F is correct. Finally, though an instance of an object that implements an interface inherits java.lang. Object, the interface itself doesn’t; otherwise, Java would support multiple inheritance for objects, which it doesn’t. Therefore, option G is incorrect.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "All methods within them are assumed to be abstract.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "Both can contain public static final variables.",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "Both can be extended using the extend keyword.",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "Both can contain default methods.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "Both can contain static methods.",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "Neither can be instantiated directly.",
            "isCorrect": true
          },
          {
            "id": 6,
            "answer": "Both inherit java.lang.Object.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 114,
        "chapterId": 4,
        "type": 2,
        "statement": "What modifiers are assumed for all interface variables? (Choose all that apply)",
        "explanation": "Interface variables are assumed to be public static final; therefore, options A, D, and E are correct. Options B and C are incorrect because interface variables must be public—interfaces are implemented by classes, not inherited by interfaces. Option F is incorrect because variables can never be abstract.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "public",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "protected",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "private",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "static",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "final",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "abstract",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 115,
        "chapterId": 4,
        "type": 1,
        "statement": "What is the output of the following code?\n1: interface Nocturnal {\n2:   default boolean isBlind() { return true; }\n3: }\n4: public class Owl implements Nocturnal {\n5: public boolean isBlind() { return false; }\n6: public static void main(String[] args) {\n7:   Nocturnal nocturnal = (Nocturnal)new Owl();\n8:   System.out.println(nocturnal.isBlind());\n9: }\n10: }",
        "explanation": "This code compiles and runs without issue, outputting false, so option B is the correct answer. The first declaration of isBlind() is as a default interface method, assumed public. The second declaration of isBlind() correctly overrides the default interface method. Finally, the newly created Owl instance may be automatically cast to a Nocturnal reference without an explicit cast, although adding it doesn’t break the code.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "true",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "false",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "The code will not compile because of line 2.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "The code will not compile because of line 5.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "The code will not compile because of line 7.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "The code will not compile because of line 8.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 116,
        "chapterId": 4,
        "type": 1,
        "statement": "What is the output of the following code?\n1: class Arthropod {\n2: public void printName(double input) { System.out .print(\"Arthropod\"); }\n3: }\n4: public class Spider extends Arthropod {\n5:   public void printName(int input) { System.out.print(\"Spider\"); }\n6:   public static void main(String[] args) {\n7:     Spider spider = new Spider();\n8:     spider.printName(4);\n9:     spider.printName(9.0);\n10:   }\n11: }",
        "explanation": "The code compiles and runs without issue, so options E and F are incorrect. The printName() method is an overload in Spider, not an override, so both methods may be called. The call on line 8 references the version that takes an int as input defined in the Spider class, and the call on line 9 references the version in the Arthropod class that takes a double. Therefore, SpiderArthropod is output and option A is the correct answer.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "SpiderArthropod",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "ArthropodSpider",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "SpiderSpider",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "ArthropodArthropod",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "The code will not compile because of line 5.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "The code will not compile because of line 9.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 117,
        "chapterId": 4,
        "type": 2,
        "statement": "Which statements are true about the following code? (Choose all that apply)\n1: interface HasVocalCords {\n2:   public abstract void makeSound();\n3: }\n4: public interface CanBark extends HasVocalCords {\n5:   public void bark();\n6: }",
        "explanation": "The code compiles without issue, so option A is wrong. Option B is incorrect, since an abstract class could implement HasVocalCords without the need to override the makeSound() method. Option C is correct; any class that implements CanBark auto- matically inherits its methods, as well as any inherited methods defined in the parent interface. Because option C is correct, it follows that option D is incorrect. Finally, an interface can extend multiple interfaces, so option E is incorrect.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "The CanBark interface doesn’t compile.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "A class that implements HasVocalCords must override the makeSound() method.",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "A class that implements CanBark inherits both the makeSound() and bark() methods.",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "A class that implements CanBark only inherits the bark() method.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "An interface cannot extend another interface.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 118,
        "chapterId": 4,
        "type": 2,
        "statement": "Which of the following is true about a concrete subclass? (Choose all that apply)",
        "explanation": "Concrete classes are, by definition, not abstract, so option A is incorrect. A concrete class must implement all inherited abstract methods, so option B is correct. Option C is incorrect; a superclass may have already implemented an inherited interface, so the concrete subclass would not need to implement the method. Concrete classes can be both final and not final, so option D is incorrect. Finally, abstract methods must be overridden by a concrete subclass, so option E is incorrect.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "A concrete subclass can be declared as abstract.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "A concrete subclass must implement all inherited abstract methods.",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "A concrete subclass must implement all methods defined in an inherited interface.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "A concrete subclass cannot be marked as final.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "Abstract methods cannot be overridden by a concrete subclass.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 119,
        "chapterId": 4,
        "type": 1,
        "statement": "What is the output of the following code?\n1: abstract class Reptile {\n2:   public final void layEggs() { System.out.println(\"Reptile laying eggs\");}\n3:   public static void main(String[] args) {\n4:     Reptile reptile = new Lizard();\n5:     reptile.layEggs();\n6:   }\n7: }\n8: public class Lizard extends Reptile {\n9:   public void layEggs() { System.out.println(\"Lizard laying eggs\"); }\n10: }",
        "explanation": "The code doesn’t compile, so options A and B are incorrect. The issue with line 9 is that layEggs() is marked as final in the superclass Reptile, which means it cannot be overridden. There are no errors on any other lines, so options C and D are incorrect.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "Reptile laying eggs",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "Lizard laying eggs",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "The code will not compile because of line 4.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "The code will not compile because of line 5.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "The code will not compile because of line 9.",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 120,
        "chapterId": 4,
        "type": 1,
        "statement": "What is the output of the following code?\n1: public abstract class Whale {\n2:   public abstract void dive() {};\n3:   public static void main(String[] args) {\n4:     Whale whale = new Orca();\n5:     whale.dive();\n6:   }\n7: }\n8: class Orca extends Whale {\n9:   public void dive(int depth) { System.out.println(\"Orca diving\"); } \n10: }",
        "explanation": "This may look like a complex question, but it is actually quite easy. Line 2 contains an invalid definition of an abstract method. Abstract methods cannot contain a body, so the code will not compile and option B is the correct answer. If the body {} was removed from line 2, the code would still not compile, although it would be line 8 that would throw the compilation error. Since dive() in Whale is abstract and Orca extends Whale, then it must implement an overridden version of dive(). The method on line 9 is an overloaded version of dive(), not an overridden version, so Orca is an invalid subclass and will not compile.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "Orca diving",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "The code will not compile because of line 2.",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "The code will not compile because of line 8.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "The code will not compile because of line 9.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "The output cannot be determined from the code provided.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 121,
        "chapterId": 4,
        "type": 2,
        "statement": "What is the output of the following code? (Choose all that apply)\n1: interface Aquatic {\n2:   public default int getNumberOfGills(int input) { return 2; }\n3: }\n4: public class ClownFish implements Aquatic {\n5:   public String getNumberOfGills() { return \"4\"; }\n6:   public String getNumberOfGills(int input) { return \"6\"; }\n7:   public static void main(String[] args) {\n8:     System.out.println(new ClownFish().getNumberOfGills(-1));\n9:   }\n10: }",
        "explanation": "The code doesn’t compile because line 6 contains an incompatible override of the getNumberOfGills(int input) method defined in the Aquatic interface. In particular, int and String are not covariant returns types, since int is not a subclass of String. Note that line 5 compiles without issue; getNumberOfGills() is an overloaded method that is not related to the parent interface method that takes an int value.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "2",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "4",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "6",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "The code will not compile because of line 5.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "The code will not compile because of line 6.",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "The code will not compile because of line 8.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 122,
        "chapterId": 4,
        "type": 2,
        "statement": "Which of the following statements can be inserted in the blank so that the code will compile successfully? (Choose all that apply)\npublic class Snake {}\npublic class Cobra extends Snake {}\n public class GardenSnake {}\npublic class SnakeHandler {\nprivate Snake snake;\npublic void setSnake(Snake snake) { this.snake = snake; }\npublic static void main(String[] args) {\nnew SnakeHandler().setSnake(_______);\n}\n}",
        "explanation": "First off, Cobra is a subclass of Snake, so option A can be used. GardenSnake is not defined as a subclass of Snake, so it cannot be used and option B is incorrect. The class Snake is not marked as abstract, so it can be instantiated and passed, so option C is correct. Next, Object is a superclass of Snake, not a subclass, so it also cannot be used and option D is incorrect. The class String is unrelated in this example, so option E is incorrect. Finally, a null value can always be passed as an object value, regardless of type, so option F is correct.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "new Cobra()",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "new GardenSnake()",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "new Snake()",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "new Object()",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "new String(\"Snake\")",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "null",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 123,
        "chapterId": 4,
        "type": 1,
        "statement": "What is the result of the following code?\n1: public abstract class Bird {\n2:   private void fly() { System.out.println(\"Bird is flying\"); }\n3:   public static void main(String[] args) {\n4:     Bird bird = new Pelican();\n5:     bird.fly();\n6:   }\n7: }\n8: class Pelican extends Bird {\n9:   protected void fly() { System.out.println(\"Pelican is flying\"); }\n10: }",
        "explanation": "The code compiles and runs without issue, so options C, D, and E are incorrect. The trick here is that the method fly() is marked as private in the parent class Bird, which means it may only be hidden, not overridden. With hidden methods, the specific method used depends on where it is referenced. Since it is referenced within the Bird class, the method declared on line 2 was used, and option A is correct. Alternatively, if the method was referenced within the Pelican class, or if the method in the parent class was marked as protected and overridden in the subclass, then the method on line 9 would have been used.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "Bird is flying",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "Pelican is flying",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "The code will not compile because of line 4.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "The code will not compile because of line 5.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "The code will not compile because of line 9.",
            "isCorrect": false
          }
        ]
      }
    ]
  },
  {
    "id": 5,
    "color": "#95A5A6",
    "name": "Exceptions",
    "questions": [
      {
        "id": 124,
        "chapterId": 5,
        "type": 2,
        "statement": "Which of the following statements are true? (Choose all that apply)",
        "explanation": "Runtime exceptions are also known as unchecked exceptions. They are allowed to be declared, but they don’t have to be. Checked exceptions must be handled or declared. Legally, you can handle java.lang.Error subclasses, but it’s not a good idea.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "Runtime exceptions are the same thing as checked exceptions.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "Runtime exceptions are the same thing as unchecked exceptions.",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "You can declare only checked exceptions.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "You can declare only unchecked exceptions.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "You can handle only Exception subclasses.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 125,
        "chapterId": 5,
        "type": 2,
        "statement": "Which of the following pairs fill in the blanks to make this code compile? (Choose all that apply)\n7: public void ohNo() _____ Exception {\n8: _____________ Exception();\n 9: }",
        "explanation": "In a method declaration, the keyword throws is used. To actually throw an exception, the keyword throw is used and a new exception is created.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "On line 7, fill in throw",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "On line 7, fill in throws",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "On line 8, fill in throw",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "On line 8, fill in throw new",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "On line 8, fill in throws",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "On line 8, fill in throws new",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 126,
        "chapterId": 5,
        "type": 1,
        "statement": "When are you required to use a finally block in a regular try statement (not a try-with- resources)?",
        "explanation": "A try statement is required to have a catch clause and/or finally clause. If it goes the catch route, it is allowed to have multiple catch clauses.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "Never",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "When the program code doesn’t terminate on its own.",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "When there are no catch blocks in a try statement.",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "When there is exactly one catch block in a try statement.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "When there are two or more catch blocks in a try statement.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 127,
        "chapterId": 5,
        "type": 2,
        "statement": "Which exception will the following throw?\nObject obj = new Integer(3);\nString str = (String) obj;\nSystem.out.println(str);",
        "explanation": "The second line tries to cast an Integer to a String. Since String does not extend Integer, this is not allowed and a ClassCastException is thrown.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "ArrayIndexOutOfBoundsException",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "ClassCastException",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "IllegalArgumentException",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "NumberFormatException",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "None of the above.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 128,
        "chapterId": 5,
        "type": 2,
        "statement": "Which of the following exceptions are thrown by the JVM? (Choose all that apply)",
        "explanation": "java.io.IOException is thrown by many methods in the java.io package, but it is always thrown programmatically. The same is true for NumberFormatExcep- tion; it is thrown programmatically by the wrapper classes of java.lang. The other three exceptions are all thrown by the JVM when the corresponding problem arises.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "ArrayIndexOutOfBoundsException",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "ExceptionInInitializerError",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "java.io.IOException",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "NullPointerException",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "NumberFormatException",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 129,
        "chapterId": 5,
        "type": 1,
        "statement": "What will happen if you add the statement System.out.println(5 / 0); to a working main() method?",
        "explanation": "The compiler tests the operation for a valid type but not a valid result, so the code will still compile and run. At runtime, evaluation of the parameter takes place before passing it to the print() method, so an ArithmeticException object is raised.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "It will not compile.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "It will not run.",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "It will run and throw an ArithmeticException.",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "It will run and throw an IllegalArgumentException.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "None of the above.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 130,
        "chapterId": 5,
        "type": 1,
        "statement": "What is printed besides the stack trace caused by the NullPointerException from line 16?\n1: public class DoSomething {\n2:   public void go() {\n3:     System.out.print(\"A\");\n4:     try {\n5:       stop();\n6:     } catch (ArithmeticException e) {\n7:       System.out.print(\"B\");\n8:     } finally {\n9:       System.out.print(\"C\");\n10:    }\n11:    System.out.print(\"D\");\n12:  }\n13:  public void stop() {\n14:    System.out.print(\"E\");\n15:    Object x = null;\n16:    x.toString();\n17:    System.out.print(\"F\");\n18:  }\n19:  public static void main(String[] args) {\n20:    new DoSomething().go();\n21:  }\n22: }",
        "explanation": "The main() method invokes go and A is printed on line 3. The stop method is invoked and E is printed on line 14. Line 16 throws a NullPointerException, so stop immediately ends and line 17 doesn’t execute. The exception isn’t caught in go, so the go method ends as well, but not before its finally block executes and C is printed on line 9. Because main() doesn’t catch the exception, the stack trace displays and no fur- ther output occurs, so AEC was the output printed before the stack trace.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "AE",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "AEBCD",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "AEC",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "AECD",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "No output appears other than the stack trace.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 131,
        "chapterId": 5,
        "type": 1,
        "statement": "What is the output of the following snippet, assuming a and b are both 0?\n3: try {\n4:   return a / b;\n5: } catch (RuntimeException e) {\n6:   return -1;\n7: } catch (ArithmeticException e) {\n8:   return 0;\n9: } finally {\n10:  System.out.print(\"done\");\n11: }",
        "explanation": "The order of catch blocks is important because they’re checked in the order they appear after the try block. Because ArithmeticException is a child class of Runtime- Exception, the catch block on line 7 is unreachable. (If an ArithmeticException is thrown in try try block, it will be caught on line 5.) Line 7 generates a compiler error because it is unreachable code.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "-1",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "0",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "done-1",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "done0",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "The code does not compile.",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "An uncaught exception is thrown.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 132,
        "chapterId": 5,
        "type": 2,
        "statement": "What is the output of the following program?\n1: public class Laptop { \n2:   public void start() {\n3:     try {\n4:       System.out.print(\"Starting up \");\n5:       throw new Exception();\n6:     } catch (Exception e) {\n7:       System.out.print(\"Problem \");\n8:       System.exit(0);\n9:     } finally {\n10:      System.out.print(\"Shutting down \");\n11:    }\n12:   }\n13:   public static void main(String[] args) {\n14:     new Laptop().start();\n15: } }",
        "explanation": "The main() method invokes start on a new Laptop object. Line 4 prints Starting up; then line 5 throws an Exception. Line 6 catches the exception, line 7 prints Problem, and then line 8 calls System.exit, which terminates the JVM. The finally block does not execute because the JVM is no longer running.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "Starting up",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "Starting up Problem",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "Starting up Problem Shutting down",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "Starting up Shutting down",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "The code does not compile.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "An uncaught exception is thrown.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 133,
        "chapterId": 5,
        "type": 1,
        "statement": "What is the output of the following program?\n1: public class Dog {\n2:   public String name;\n3:   public void parseName() {\n4:     System.out.print(\"1\");\n5:     try {\n6:       System.out.print(\"2\");\n7:       int x = Integer.parseInt(name);\n8:       System.out.print(\"3\");\n9:     } catch (NumberFormatException e) {\n10:      System.out.print(\"4\");\n11:    }\n12:   }\n13:   public static void main(String[] args) {\n14:     Dog leroy = new Dog();\n15:     leroy.name = \"Leroy\"\n16:     leroy.parseName();\n17:     System.out.print(\"5\")\n18: } }",
        "explanation": "The parseNamemethod is invoked within main() on a newDog object.Line4 prints 1. The try block executes and 2 is printed. Line 7 throws a NumberFormatException, so line 8 doesn’t execute. The exception is caught on line 9, and line 10 prints 4. Because the exception is handled, execution resumes normally. parseName runs to completion, and line 17 executes, printing 5. That’s the end of the program, so the output is 1245.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "12",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "1234",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "1235",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "124",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "1245",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "The code does not compile.",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "An uncaught exception is thrown.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 134,
        "chapterId": 5,
        "type": 2,
        "statement": "What is the output of the following program?\n1: public class Cat {\n2:   public String name;\n3:   public void parseName() {\n4:     System.out.print(\"1\");\n5:     try {\n6:       System.out.print(\"2\");\n7:       int x = Integer.parseInt(name);\n8:       System.out.print(\"3\");\n9:     } catch (NullPointerException e) {\n10:      System.out.print(\"4\");\n11:    }\n12:    System.out.print(\"5\");\n13:  }\n14:  public static void main(String[] args) {\n15:    Cat leo = new Cat();\n16:    leo.name = \"Leo\";\n17:    leo.parseName();\n18:    System.out.print(\"6\");\n19:  }\n20: }",
        "explanation": "The parseName method is invoked on a new Cat object. Line 4 prints 1. The try block is entered, and line 6 prints 2. Line 7 throws a NumberFormatException. It isn’t caught, so parseName ends. main() doesn’t catch the exception either, so the program terminates and the stack trace for the NumberFormatException is printed.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "12, followed by a stack trace for a NumberFormatException",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "124, followed by a stack trace for a NumberFormatException",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "12456",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "12456",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "1256, followed by a stack trace for a NumberFormatException",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "The code does not compile.",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "An uncaught exception is thrown",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 135,
        "chapterId": 5,
        "type": 2,
        "statement": "What is printed by the following? (Choose all that apply)\n1: public class Mouse {\n2:   public String name;\n3:   public void run() {\n4:     System.out.print(\"1\");\n5:     try {\n6:       System.out.print(\"2\");\n7:       name.toString();\n8:       System.out.print(\"3\");\n9:     } catch (NullPointerException e) {\n10:      System.out.print(\"4\");\n11:      throw e;\n12:    }\n13:    System.out.print(\"5\");\n14:   }\n15:   public static void main(String[] args) {\n16:     Mouse jerry = new Mouse();\n17:     jerry.run();\n18:     System.out.print(\"6\");\n19: } }",
        "explanation": "The main() method invokes run on a new Mouse object. Line 4 prints 1 and line 6 prints 2, so options A and B are correct. Line 7 throws a NullPointerException, which causes line 8 to be skipped, so C is incorrect. The exception is caught on line 9 and line 10 prints 4, so option D is correct. Line 11 throws the exception again, which causes run() to immediately end, so line 13 doesn’t execute and option E is incorrect. The main() method doesn’t catch the exception either, so line 18 doesn’t execute and option F is incorrect. The uncaught NullPointerException causes the stack trace to be printed, so option G is correct.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "1",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "2",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "3",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "4",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "5",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "6",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "The stack trace for a NullPointerException",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 136,
        "chapterId": 5,
        "type": 2,
        "statement": "Which of the following statements are true? (Choose all that apply)",
        "explanation": "Classes listed in the throws part of a method declaration must extend java.lang.Throwable. This includes Error, Exception, and RuntimeException. Arbi- trary classes such as String can’t go there. Any Java type, including Exception, can be declared as the return type. However, this will simply return the object rather than throw an exception.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "You can declare a method with Exception as the return type.",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "You can declare any subclass of Error in the throws part of a method declaration.",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "You can declare any subclass of Exception in the throws part of a method declaration.",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "You can declare any subclass of Object in the throws part of a method declaration.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "You can declare any subclass of RuntimeException in the throws part of a method declaration.",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 137,
        "chapterId": 5,
        "type": 2,
        "statement": "Which of the following can be inserted on line 8 to make this code compile? (Choose all that apply)\n7: public void ohNo() throws IOException {)\n8: // INSERT CODE HERE)\n9: }",
        "explanation": "A method that declares an exception isn’t required to throw one, making option A correct. Runtime exceptions can be thrown in any method, making options C and E correct. Option D matches the exception type declared and so is also correct. Option B is incorrect because a broader exception is not allowed.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "System.out.println(\"it's ok\");",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "throw new Exception();",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "throw new IllegalArgumentException();",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "throw new java.io.IOException();",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "throw new RuntimeException();",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 138,
        "chapterId": 5,
        "type": 2,
        "statement": "Which of the following are unchecked exceptions? (Choose all that apply)",
        "explanation": "ArrayIndexOutOfBoundsException, IllegalArgumentException, and Num- berFormatException are runtime exceptions. Sorry, you have to memorize them. Any class that extends RuntimeException is a runtime (unchecked) exception. Classes that extend Exception but not RuntimeException are checked exceptions.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "ArrayIndexOutOfBoundsException",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "IllegalArgumentException",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "IOException",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "NumberFormatException",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "Any exception that extends RuntimeException",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "Any exception that extends Exception",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 139,
        "chapterId": 5,
        "type": 1,
        "statement": "Which scenario is the best use of an exception?",
        "explanation": "IllegalArgumentException is used when an unexpected parameter is passed into a method. Option A is incorrect because returning null or -1 is a common return value for this scenario. Option D is incorrect because a for loop is typically used for this scenario. Option E is incorrect because you should find out how to code the method and not leave it for the unsuspecting programmer who calls your method. Option C is incorrect because you should run!",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "An element is not found when searching a list.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "An unexpected parameter is passed into a method.",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "The computer caught fire.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "You want to loop through a list.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "You don’t know how to code a method.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 140,
        "chapterId": 5,
        "type": 2,
        "statement": "Which of the following can be inserted into Lion to make this code compile? (Choose all that apply)\nclass HasSoreThroatException extends Exception {}\nclass TiredException extends RuntimeException {}\ninterface Roar {\nvoid roar() throws HasSoreThroatException;\n}\nclass Lion implements Roar {// INSERT CODE HERE\n}",
        "explanation": "The method is allowed to throw no exceptions at all, making option A cor- rect. It is also allowed to throw runtime exceptions, making options D and E correct. Option C is also correct since it matches the signature in the interface.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "public void roar(){}",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "public void roar() throws Exception{}",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "public void roar() throws HasSoreThroatException{}",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "public void roar() throws IllegalArgumentException{}",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "public void roar() throws TiredException{}",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 141,
        "chapterId": 5,
        "type": 2,
        "statement": "Which of the following are true? (Choose all that apply)",
        "explanation": "Checked exceptions are required to be handled or declared. Runtime exceptions are allowed to be handled or declared. Errors are allowed to be handled or declared, but this is bad practice.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "Checked exceptions are allowed to be handled or declared.",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "Checked exceptions are required to be handled or declared.",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "Errors are allowed to be handled or declared.",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "Errors are required to be handled or declared.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "Runtime exceptions are allowed to be handled or declared.",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "Runtime exceptions are required to be handled or declared.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 142,
        "chapterId": 5,
        "type": 2,
        "statement": "Which of the following can be inserted in the blank to make the code compile? (Choose all that apply)\npublic static void main(String[] args) {\ntry {\nSystem.out.println(\"work real hard\");\n} catch (______ e) {\n} catch (RuntimeException e) {\n}\n}",
        "explanation": "Option C is allowed because it is a more specific type than RuntimeException. Option E is allowed because it isn’t in the same inheritance tree as RuntimeExcep- tion. It’s not a good idea to catch either of these. Option B is not allowed because the method called inside the try block doesn’t declare an IOException to be thrown. The compiler realizes that IOException would be an unreachable catch block. Option D is not allowed because the same exception can’t be specified in two different catch blocks. Finally, option A is not allowed because it’s more general than RuntimeExcep- tion and would make that block unreachable.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "Exception",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "IOException",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "IllegalArgumentException",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "RuntimeException",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "StackOverflowError",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "None of the above.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 143,
        "chapterId": 5,
        "type": 2,
        "statement": "What does the output of the following contain? (Choose all that apply)\n12: public static void main(String[] args) {\n13:   System.out.print(\"a\");\n14:   try {\n15:     System.out.print(\"b\");\n16:     throw new IllegalArgumentException();\n17:   } catch (IllegalArgumentException e) {\n18:     System.out.print(\"c\");\n19:     throw new RuntimeException(\"1\");\n20:   } catch (RuntimeException e) {\n21:     System.out.print(\"d\");\n22:     throw new RuntimeException(\"2\");\n23:   } finally {\n24:     System.out.print(\"e\");\n25:     throw new RuntimeException(\"3\");\n26:   }\n27: }",
        "explanation": "The code begins normally and prints a on line 13, followed by b on line 15. On line 16, it throws an exception that’s caught on line 17. Remember, only the most spe- cific matching catch is run. Line 18 prints c, and then line 19 throws another excep- tion. Regardless, the finally block runs, printing e. Since the finally block also throws an exception, that’s the one printed.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "abce",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "abde",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "An exception with the message set to \"1\"",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "An exception with the message set to \"2\"",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "An exception with the message set to \"3\"",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "Nothing; the code does not compile.",
            "isCorrect": false
          }
        ]
      }
    ]
  }
]